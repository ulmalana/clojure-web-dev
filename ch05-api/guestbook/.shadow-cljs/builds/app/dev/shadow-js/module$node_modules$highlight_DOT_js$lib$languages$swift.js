["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/highlight_DOT_js/lib/languages/swift.js"],"~:js","shadow$provide.module$node_modules$highlight_DOT_js$lib$languages$swift=function(global,require,module,exports){function concat(args){for(var $jscomp$restParams=[],$jscomp$restIndex=0;$jscomp$restIndex<arguments.length;++$jscomp$restIndex)$jscomp$restParams[$jscomp$restIndex-0]=arguments[$jscomp$restIndex];return $jscomp$restParams.map(function(x){return x?\"string\"===typeof x?x:x.source:null}).join(\"\")}function stripOptionsFromArgs(args){var opts=args[args.length-1];return\"object\"===typeof opts&&\nopts.constructor===Object?(args.splice(args.length-1,1),opts):{}}function either(args){for(var $jscomp$restParams=[],$jscomp$restIndex=0;$jscomp$restIndex<arguments.length;++$jscomp$restIndex)$jscomp$restParams[$jscomp$restIndex-0]=arguments[$jscomp$restIndex];return\"(\"+(stripOptionsFromArgs($jscomp$restParams).capture?\"\":\"?:\")+$jscomp$restParams.map(function(x){return x?\"string\"===typeof x?x:x.source:null}).join(\"|\")+\")\"}var keywordWrapper=function(keyword){return concat(/\\b/,keyword,/\\w$/.test(keyword)?\n/\\b/:/\\B/)},dotKeywords=[\"Protocol\",\"Type\"].map(keywordWrapper),optionalDotKeywords=[\"init\",\"self\"].map(keywordWrapper),keywordTypes=[\"Any\",\"Self\"],keywords=[\"actor\",\"associatedtype\",\"async\",\"await\",/as\\?/,/as!/,\"as\",\"break\",\"case\",\"catch\",\"class\",\"continue\",\"convenience\",\"default\",\"defer\",\"deinit\",\"didSet\",\"do\",\"dynamic\",\"else\",\"enum\",\"extension\",\"fallthrough\",/fileprivate\\(set\\)/,\"fileprivate\",\"final\",\"for\",\"func\",\"get\",\"guard\",\"if\",\"import\",\"indirect\",\"infix\",/init\\?/,/init!/,\"inout\",/internal\\(set\\)/,\n\"internal\",\"in\",\"is\",\"lazy\",\"let\",\"mutating\",\"nonmutating\",/open\\(set\\)/,\"open\",\"operator\",\"optional\",\"override\",\"postfix\",\"precedencegroup\",\"prefix\",/private\\(set\\)/,\"private\",\"protocol\",/public\\(set\\)/,\"public\",\"repeat\",\"required\",\"rethrows\",\"return\",\"set\",\"some\",\"static\",\"struct\",\"subscript\",\"super\",\"switch\",\"throws\",\"throw\",/try\\?/,/try!/,\"try\",\"typealias\",/unowned\\(safe\\)/,/unowned\\(unsafe\\)/,\"unowned\",\"var\",\"weak\",\"where\",\"while\",\"willSet\"],literals=[\"false\",\"nil\",\"true\"],precedencegroupKeywords=\n\"assignment associativity higherThan left lowerThan none right\".split(\" \"),numberSignKeywords=\"#colorLiteral #column #dsohandle #else #elseif #endif #error #file #fileID #fileLiteral #filePath #function #if #imageLiteral #keyPath #line #selector #sourceLocation #warn_unqualified_access #warning\".split(\" \"),builtIns=\"abs all any assert assertionFailure debugPrint dump fatalError getVaList isKnownUniquelyReferenced max min numericCast pointwiseMax pointwiseMin precondition preconditionFailure print readLine repeatElement sequence stride swap swift_unboxFromSwiftValueWithType transcode type unsafeBitCast unsafeDowncast withExtendedLifetime withUnsafeMutablePointer withUnsafePointer withVaList withoutActuallyEscaping zip\".split(\" \");\nglobal=either(/[/=\\-+!*%<>&|^~?]/,/[\\u00A1-\\u00A7]/,/[\\u00A9\\u00AB]/,/[\\u00AC\\u00AE]/,/[\\u00B0\\u00B1]/,/[\\u00B6\\u00BB\\u00BF\\u00D7\\u00F7]/,/[\\u2016-\\u2017]/,/[\\u2020-\\u2027]/,/[\\u2030-\\u203E]/,/[\\u2041-\\u2053]/,/[\\u2055-\\u205E]/,/[\\u2190-\\u23FF]/,/[\\u2500-\\u2775]/,/[\\u2794-\\u2BFF]/,/[\\u2E00-\\u2E7F]/,/[\\u3001-\\u3003]/,/[\\u3008-\\u3020]/,/[\\u3030]/);var operatorCharacter=either(global,/[\\u0300-\\u036F]/,/[\\u1DC0-\\u1DFF]/,/[\\u20D0-\\u20FF]/,/[\\uFE00-\\uFE0F]/,/[\\uFE20-\\uFE2F]/),operator=concat(global,operatorCharacter,\n\"*\");global=either(/[a-zA-Z_]/,/[\\u00A8\\u00AA\\u00AD\\u00AF\\u00B2-\\u00B5\\u00B7-\\u00BA]/,/[\\u00BC-\\u00BE\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u00FF]/,/[\\u0100-\\u02FF\\u0370-\\u167F\\u1681-\\u180D\\u180F-\\u1DBF]/,/[\\u1E00-\\u1FFF]/,/[\\u200B-\\u200D\\u202A-\\u202E\\u203F-\\u2040\\u2054\\u2060-\\u206F]/,/[\\u2070-\\u20CF\\u2100-\\u218F\\u2460-\\u24FF\\u2776-\\u2793]/,/[\\u2C00-\\u2DFF\\u2E80-\\u2FFF]/,/[\\u3004-\\u3007\\u3021-\\u302F\\u3031-\\u303F\\u3040-\\uD7FF]/,/[\\uF900-\\uFD3D\\uFD40-\\uFDCF\\uFDF0-\\uFE1F\\uFE30-\\uFE44]/,/[\\uFE47-\\uFEFE\\uFF00-\\uFFFD]/);\nvar identifierCharacter=either(global,/\\d/,/[\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]/),identifier=concat(global,identifierCharacter,\"*\"),typeIdentifier=concat(/[A-Z]/,identifierCharacter,\"*\"),keywordAttributes=[\"autoclosure\",concat(/convention\\(/,either(\"swift\",\"block\",\"c\"),/\\)/),\"discardableResult\",\"dynamicCallable\",\"dynamicMemberLookup\",\"escaping\",\"frozen\",\"GKInspectable\",\"IBAction\",\"IBDesignable\",\"IBInspectable\",\"IBOutlet\",\"IBSegueAction\",\"inlinable\",\"main\",\"nonobjc\",\"NSApplicationMain\",\n\"NSCopying\",\"NSManaged\",concat(/objc\\(/,identifier,/\\)/),\"objc\",\"objcMembers\",\"propertyWrapper\",\"requires_stored_property_inits\",\"resultBuilder\",\"testable\",\"UIApplicationMain\",\"unknown\",\"usableFromInline\"],availabilityKeywords=\"iOS iOSApplicationExtension macOS macOSApplicationExtension macCatalyst macCatalystApplicationExtension watchOS watchOSApplicationExtension tvOS tvOSApplicationExtension swift\".split(\" \");module.exports=function(hljs){var WHITESPACE={match:/\\s+/,relevance:0},BLOCK_COMMENT=\nhljs.COMMENT(\"/\\\\*\",\"\\\\*/\",{contains:[\"self\"]});BLOCK_COMMENT=[hljs.C_LINE_COMMENT_MODE,BLOCK_COMMENT];var DOT_KEYWORD={match:[/\\./,either.apply(null,[].concat($jscomp.arrayFromIterable(dotKeywords),$jscomp.arrayFromIterable(optionalDotKeywords)))],className:{2:\"keyword\"}},KEYWORD_GUARD={match:concat(/\\./,either.apply(null,$jscomp.arrayFromIterable(keywords))),relevance:0},PLAIN_KEYWORDS=keywords.filter(function(kw){return\"string\"===typeof kw}).concat([\"_|0\"]),REGEX_KEYWORDS=keywords.filter(function(kw){return\"string\"!==\ntypeof kw}).concat(keywordTypes).map(keywordWrapper);REGEX_KEYWORDS={variants:[{className:\"keyword\",match:either.apply(null,[].concat($jscomp.arrayFromIterable(REGEX_KEYWORDS),$jscomp.arrayFromIterable(optionalDotKeywords)))}]};PLAIN_KEYWORDS={$pattern:either(/\\b\\w+/,/#\\w+/),keyword:PLAIN_KEYWORDS.concat(numberSignKeywords),literal:literals};DOT_KEYWORD=[DOT_KEYWORD,KEYWORD_GUARD,REGEX_KEYWORDS];KEYWORD_GUARD={match:concat(/\\./,either.apply(null,$jscomp.arrayFromIterable(builtIns))),relevance:0};\nREGEX_KEYWORDS={className:\"built_in\",match:concat(/\\b/,either.apply(null,$jscomp.arrayFromIterable(builtIns)),/(?=\\()/)};KEYWORD_GUARD=[KEYWORD_GUARD,REGEX_KEYWORDS];var OPERATOR_GUARD={match:/->/,relevance:0};REGEX_KEYWORDS=[OPERATOR_GUARD,{className:\"operator\",relevance:0,variants:[{match:operator},{match:\"\\\\.(\\\\.|\"+operatorCharacter+\")+\"}]}];var NUMBER={className:\"number\",relevance:0,variants:[{match:\"\\\\b(([0-9]_*)+)(\\\\.(([0-9]_*)+))?([eE][+-]?(([0-9]_*)+))?\\\\b\"},{match:\"\\\\b0x(([0-9a-fA-F]_*)+)(\\\\.(([0-9a-fA-F]_*)+))?([pP][+-]?(([0-9]_*)+))?\\\\b\"},\n{match:/\\b0o([0-7]_*)+\\b/},{match:/\\b0b([01]_*)+\\b/}]},ESCAPED_CHARACTER=function(rawDelimiter){rawDelimiter=void 0===rawDelimiter?\"\":rawDelimiter;return{className:\"subst\",variants:[{match:concat(/\\\\/,rawDelimiter,/[0\\\\tnr\"']/)},{match:concat(/\\\\/,rawDelimiter,/u\\{[0-9a-fA-F]{1,8}\\}/)}]}},INTERPOLATION=function(rawDelimiter){return{className:\"subst\",label:\"interpol\",begin:concat(/\\\\/,void 0===rawDelimiter?\"\":rawDelimiter,/\\(/),end:/\\)/}},MULTILINE_STRING=function(rawDelimiter){rawDelimiter=void 0===\nrawDelimiter?\"\":rawDelimiter;var JSCompiler_temp_const=concat(rawDelimiter,/\"\"\"/),JSCompiler_temp_const$jscomp$0=concat(/\"\"\"/,rawDelimiter),JSCompiler_temp_const$jscomp$1=ESCAPED_CHARACTER(rawDelimiter);var JSCompiler_inline_result=rawDelimiter;JSCompiler_inline_result={className:\"subst\",match:concat(/\\\\/,void 0===JSCompiler_inline_result?\"\":JSCompiler_inline_result,/[\\t ]*(?:[\\r\\n]|\\r\\n)/)};return{begin:JSCompiler_temp_const,end:JSCompiler_temp_const$jscomp$0,contains:[JSCompiler_temp_const$jscomp$1,\nJSCompiler_inline_result,INTERPOLATION(rawDelimiter)]}},SINGLE_LINE_STRING=function(rawDelimiter){rawDelimiter=void 0===rawDelimiter?\"\":rawDelimiter;return{begin:concat(rawDelimiter,/\"/),end:concat(/\"/,rawDelimiter),contains:[ESCAPED_CHARACTER(rawDelimiter),INTERPOLATION(rawDelimiter)]}};MULTILINE_STRING={className:\"string\",variants:[MULTILINE_STRING(),MULTILINE_STRING(\"#\"),MULTILINE_STRING(\"##\"),MULTILINE_STRING(\"###\"),SINGLE_LINE_STRING(),SINGLE_LINE_STRING(\"#\"),SINGLE_LINE_STRING(\"##\"),SINGLE_LINE_STRING(\"###\")]};\nvar QUOTED_IDENTIFIER={match:concat(/`/,identifier,/`/)};SINGLE_LINE_STRING=[QUOTED_IDENTIFIER,{className:\"variable\",match:/\\$\\d+/},{className:\"variable\",match:\"\\\\$\"+identifierCharacter+\"+\"}];var AVAILABLE_ATTRIBUTE={match:/(@|#)available/,className:\"keyword\",starts:{contains:[{begin:/\\(/,end:/\\)/,keywords:availabilityKeywords,contains:[].concat($jscomp.arrayFromIterable(REGEX_KEYWORDS),[NUMBER,MULTILINE_STRING])}]}},KEYWORD_ATTRIBUTE={className:\"keyword\",match:concat(/@/,either.apply(null,$jscomp.arrayFromIterable(keywordAttributes)))},\nUSER_DEFINED_ATTRIBUTE={className:\"meta\",match:concat(/@/,identifier)};AVAILABLE_ATTRIBUTE=[AVAILABLE_ATTRIBUTE,KEYWORD_ATTRIBUTE,USER_DEFINED_ATTRIBUTE];KEYWORD_ATTRIBUTE={match:concat(\"(?\\x3d\",/\\b[A-Z]/,\")\"),relevance:0,contains:[{className:\"type\",match:concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/,identifierCharacter,\"+\")},{className:\"type\",match:typeIdentifier,relevance:0},{match:/[?!]+/,relevance:0},{match:/\\.\\.\\./,relevance:0},{match:concat(/\\s+&\\s+/,concat(\"(?\\x3d\",\ntypeIdentifier,\")\")),relevance:0}]};OPERATOR_GUARD={begin:/</,end:/>/,keywords:PLAIN_KEYWORDS,contains:[].concat($jscomp.arrayFromIterable(BLOCK_COMMENT),$jscomp.arrayFromIterable(DOT_KEYWORD),$jscomp.arrayFromIterable(AVAILABLE_ATTRIBUTE),[OPERATOR_GUARD,KEYWORD_ATTRIBUTE])};KEYWORD_ATTRIBUTE.contains.push(OPERATOR_GUARD);OPERATOR_GUARD={match:concat(identifier,/\\s*:/),keywords:\"_|0\",relevance:0};OPERATOR_GUARD={begin:/\\(/,end:/\\)/,relevance:0,keywords:PLAIN_KEYWORDS,contains:[\"self\",OPERATOR_GUARD].concat($jscomp.arrayFromIterable(BLOCK_COMMENT),\n$jscomp.arrayFromIterable(DOT_KEYWORD),$jscomp.arrayFromIterable(KEYWORD_GUARD),$jscomp.arrayFromIterable(REGEX_KEYWORDS),[NUMBER,MULTILINE_STRING],$jscomp.arrayFromIterable(SINGLE_LINE_STRING),$jscomp.arrayFromIterable(AVAILABLE_ATTRIBUTE),[KEYWORD_ATTRIBUTE])};USER_DEFINED_ATTRIBUTE={begin:/</,end:/>/,contains:[].concat($jscomp.arrayFromIterable(BLOCK_COMMENT),[KEYWORD_ATTRIBUTE])};var FUNCTION_PARAMETER_NAME={begin:either(concat(\"(?\\x3d\",concat(identifier,/\\s*:/),\")\"),concat(\"(?\\x3d\",concat(identifier,\n/\\s+/,identifier,/\\s*:/),\")\")),end:/:/,relevance:0,contains:[{className:\"keyword\",match:/\\b_\\b/},{className:\"params\",match:identifier}]};FUNCTION_PARAMETER_NAME={begin:/\\(/,end:/\\)/,keywords:PLAIN_KEYWORDS,contains:[FUNCTION_PARAMETER_NAME].concat($jscomp.arrayFromIterable(BLOCK_COMMENT),$jscomp.arrayFromIterable(DOT_KEYWORD),$jscomp.arrayFromIterable(REGEX_KEYWORDS),[NUMBER,MULTILINE_STRING],$jscomp.arrayFromIterable(AVAILABLE_ATTRIBUTE),[KEYWORD_ATTRIBUTE,OPERATOR_GUARD]),endsParent:!0,illegal:/[\"']/};\nQUOTED_IDENTIFIER={match:[/func/,/\\s+/,either(QUOTED_IDENTIFIER.match,identifier,operator)],className:{1:\"keyword\",3:\"title.function\"},contains:[USER_DEFINED_ATTRIBUTE,FUNCTION_PARAMETER_NAME,WHITESPACE],illegal:[/\\[/,/%/]};WHITESPACE={match:[/\\b(?:subscript|init[?!]?)/,/\\s*(?=[<(])/],className:{1:\"keyword\"},contains:[USER_DEFINED_ATTRIBUTE,FUNCTION_PARAMETER_NAME,WHITESPACE],illegal:/\\[|%/};USER_DEFINED_ATTRIBUTE={match:[/operator/,/\\s+/,operator],className:{1:\"keyword\",3:\"title\"}};FUNCTION_PARAMETER_NAME=\n{begin:[/precedencegroup/,/\\s+/,typeIdentifier],className:{1:\"keyword\",3:\"title\"},contains:[KEYWORD_ATTRIBUTE],keywords:[].concat($jscomp.arrayFromIterable(precedencegroupKeywords),$jscomp.arrayFromIterable(literals)),end:/}/};for(var $jscomp$iter$2=$jscomp.makeIterator(MULTILINE_STRING.variants),$jscomp$key$variant=$jscomp$iter$2.next();!$jscomp$key$variant.done;$jscomp$key$variant=$jscomp$iter$2.next()){$jscomp$key$variant=$jscomp$key$variant.value.contains.find(function(mode){return\"interpol\"===\nmode.label});$jscomp$key$variant.keywords=PLAIN_KEYWORDS;var submodes=[].concat($jscomp.arrayFromIterable(DOT_KEYWORD),$jscomp.arrayFromIterable(KEYWORD_GUARD),$jscomp.arrayFromIterable(REGEX_KEYWORDS),[NUMBER,MULTILINE_STRING],$jscomp.arrayFromIterable(SINGLE_LINE_STRING));$jscomp$key$variant.contains=[].concat($jscomp.arrayFromIterable(submodes),[{begin:/\\(/,end:/\\)/,contains:[\"self\"].concat($jscomp.arrayFromIterable(submodes))}])}return{name:\"Swift\",keywords:PLAIN_KEYWORDS,contains:[].concat($jscomp.arrayFromIterable(BLOCK_COMMENT),\n[QUOTED_IDENTIFIER,WHITESPACE,{beginKeywords:\"struct protocol class extension enum actor\",end:\"\\\\{\",excludeEnd:!0,keywords:PLAIN_KEYWORDS,contains:[hljs.inherit(hljs.TITLE_MODE,{className:\"title.class\",begin:/[A-Za-z$_][\\u00C0-\\u02B80-9A-Za-z$_]*/})].concat($jscomp.arrayFromIterable(DOT_KEYWORD))},USER_DEFINED_ATTRIBUTE,FUNCTION_PARAMETER_NAME,{beginKeywords:\"import\",end:/$/,contains:[].concat($jscomp.arrayFromIterable(BLOCK_COMMENT)),relevance:0}],$jscomp.arrayFromIterable(DOT_KEYWORD),$jscomp.arrayFromIterable(KEYWORD_GUARD),\n$jscomp.arrayFromIterable(REGEX_KEYWORDS),[NUMBER,MULTILINE_STRING],$jscomp.arrayFromIterable(SINGLE_LINE_STRING),$jscomp.arrayFromIterable(AVAILABLE_ATTRIBUTE),[KEYWORD_ATTRIBUTE,OPERATOR_GUARD])}}}","~:source","shadow$provide[\"module$node_modules$highlight_DOT_js$lib$languages$swift\"] = function(global,require,module,exports) {\n/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\nfunction stripOptionsFromArgs(args) {\n  const opts = args[args.length - 1];\n\n  if (typeof opts === 'object' && opts.constructor === Object) {\n    args.splice(args.length - 1, 1);\n    return opts;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\nfunction either(...args) {\n  const opts = stripOptionsFromArgs(args);\n  const joined = '(' +\n    (opts.capture ? \"\" : \"?:\") +\n    args.map((x) => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\nconst keywordWrapper = keyword => concat(\n  /\\b/,\n  keyword,\n  /\\w$/.test(keyword) ? /\\b/ : /\\B/\n);\n\n// Keywords that require a leading dot.\nconst dotKeywords = [\n  'Protocol', // contextual\n  'Type' // contextual\n].map(keywordWrapper);\n\n// Keywords that may have a leading dot.\nconst optionalDotKeywords = [\n  'init',\n  'self'\n].map(keywordWrapper);\n\n// should register as keyword, not type\nconst keywordTypes = [\n  'Any',\n  'Self'\n];\n\n// Regular keywords and literals.\nconst keywords = [\n  // strings below will be fed into the regular `keywords` engine while regex\n  // will result in additional modes being created to scan for those keywords to\n  // avoid conflicts with other rules\n  'actor',\n  'associatedtype',\n  'async',\n  'await',\n  /as\\?/, // operator\n  /as!/, // operator\n  'as', // operator\n  'break',\n  'case',\n  'catch',\n  'class',\n  'continue',\n  'convenience', // contextual\n  'default',\n  'defer',\n  'deinit',\n  'didSet', // contextual\n  'do',\n  'dynamic', // contextual\n  'else',\n  'enum',\n  'extension',\n  'fallthrough',\n  /fileprivate\\(set\\)/,\n  'fileprivate',\n  'final', // contextual\n  'for',\n  'func',\n  'get', // contextual\n  'guard',\n  'if',\n  'import',\n  'indirect', // contextual\n  'infix', // contextual\n  /init\\?/,\n  /init!/,\n  'inout',\n  /internal\\(set\\)/,\n  'internal',\n  'in',\n  'is', // operator\n  'lazy', // contextual\n  'let',\n  'mutating', // contextual\n  'nonmutating', // contextual\n  /open\\(set\\)/, // contextual\n  'open', // contextual\n  'operator',\n  'optional', // contextual\n  'override', // contextual\n  'postfix', // contextual\n  'precedencegroup',\n  'prefix', // contextual\n  /private\\(set\\)/,\n  'private',\n  'protocol',\n  /public\\(set\\)/,\n  'public',\n  'repeat',\n  'required', // contextual\n  'rethrows',\n  'return',\n  'set', // contextual\n  'some', // contextual\n  'static',\n  'struct',\n  'subscript',\n  'super',\n  'switch',\n  'throws',\n  'throw',\n  /try\\?/, // operator\n  /try!/, // operator\n  'try', // operator\n  'typealias',\n  /unowned\\(safe\\)/, // contextual\n  /unowned\\(unsafe\\)/, // contextual\n  'unowned', // contextual\n  'var',\n  'weak', // contextual\n  'where',\n  'while',\n  'willSet' // contextual\n];\n\n// NOTE: Contextual keywords are reserved only in specific contexts.\n// Ideally, these should be matched using modes to avoid false positives.\n\n// Literals.\nconst literals = [\n  'false',\n  'nil',\n  'true'\n];\n\n// Keywords used in precedence groups.\nconst precedencegroupKeywords = [\n  'assignment',\n  'associativity',\n  'higherThan',\n  'left',\n  'lowerThan',\n  'none',\n  'right'\n];\n\n// Keywords that start with a number sign (#).\n// #available is handled separately.\nconst numberSignKeywords = [\n  '#colorLiteral',\n  '#column',\n  '#dsohandle',\n  '#else',\n  '#elseif',\n  '#endif',\n  '#error',\n  '#file',\n  '#fileID',\n  '#fileLiteral',\n  '#filePath',\n  '#function',\n  '#if',\n  '#imageLiteral',\n  '#keyPath',\n  '#line',\n  '#selector',\n  '#sourceLocation',\n  '#warn_unqualified_access',\n  '#warning'\n];\n\n// Global functions in the Standard Library.\nconst builtIns = [\n  'abs',\n  'all',\n  'any',\n  'assert',\n  'assertionFailure',\n  'debugPrint',\n  'dump',\n  'fatalError',\n  'getVaList',\n  'isKnownUniquelyReferenced',\n  'max',\n  'min',\n  'numericCast',\n  'pointwiseMax',\n  'pointwiseMin',\n  'precondition',\n  'preconditionFailure',\n  'print',\n  'readLine',\n  'repeatElement',\n  'sequence',\n  'stride',\n  'swap',\n  'swift_unboxFromSwiftValueWithType',\n  'transcode',\n  'type',\n  'unsafeBitCast',\n  'unsafeDowncast',\n  'withExtendedLifetime',\n  'withUnsafeMutablePointer',\n  'withUnsafePointer',\n  'withVaList',\n  'withoutActuallyEscaping',\n  'zip'\n];\n\n// Valid first characters for operators.\nconst operatorHead = either(\n  /[/=\\-+!*%<>&|^~?]/,\n  /[\\u00A1-\\u00A7]/,\n  /[\\u00A9\\u00AB]/,\n  /[\\u00AC\\u00AE]/,\n  /[\\u00B0\\u00B1]/,\n  /[\\u00B6\\u00BB\\u00BF\\u00D7\\u00F7]/,\n  /[\\u2016-\\u2017]/,\n  /[\\u2020-\\u2027]/,\n  /[\\u2030-\\u203E]/,\n  /[\\u2041-\\u2053]/,\n  /[\\u2055-\\u205E]/,\n  /[\\u2190-\\u23FF]/,\n  /[\\u2500-\\u2775]/,\n  /[\\u2794-\\u2BFF]/,\n  /[\\u2E00-\\u2E7F]/,\n  /[\\u3001-\\u3003]/,\n  /[\\u3008-\\u3020]/,\n  /[\\u3030]/\n);\n\n// Valid characters for operators.\nconst operatorCharacter = either(\n  operatorHead,\n  /[\\u0300-\\u036F]/,\n  /[\\u1DC0-\\u1DFF]/,\n  /[\\u20D0-\\u20FF]/,\n  /[\\uFE00-\\uFE0F]/,\n  /[\\uFE20-\\uFE2F]/\n  // TODO: The following characters are also allowed, but the regex isn't supported yet.\n  // /[\\u{E0100}-\\u{E01EF}]/u\n);\n\n// Valid operator.\nconst operator = concat(operatorHead, operatorCharacter, '*');\n\n// Valid first characters for identifiers.\nconst identifierHead = either(\n  /[a-zA-Z_]/,\n  /[\\u00A8\\u00AA\\u00AD\\u00AF\\u00B2-\\u00B5\\u00B7-\\u00BA]/,\n  /[\\u00BC-\\u00BE\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u00FF]/,\n  /[\\u0100-\\u02FF\\u0370-\\u167F\\u1681-\\u180D\\u180F-\\u1DBF]/,\n  /[\\u1E00-\\u1FFF]/,\n  /[\\u200B-\\u200D\\u202A-\\u202E\\u203F-\\u2040\\u2054\\u2060-\\u206F]/,\n  /[\\u2070-\\u20CF\\u2100-\\u218F\\u2460-\\u24FF\\u2776-\\u2793]/,\n  /[\\u2C00-\\u2DFF\\u2E80-\\u2FFF]/,\n  /[\\u3004-\\u3007\\u3021-\\u302F\\u3031-\\u303F\\u3040-\\uD7FF]/,\n  /[\\uF900-\\uFD3D\\uFD40-\\uFDCF\\uFDF0-\\uFE1F\\uFE30-\\uFE44]/,\n  /[\\uFE47-\\uFEFE\\uFF00-\\uFFFD]/ // Should be /[\\uFE47-\\uFFFD]/, but we have to exclude FEFF.\n  // The following characters are also allowed, but the regexes aren't supported yet.\n  // /[\\u{10000}-\\u{1FFFD}\\u{20000-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}]/u,\n  // /[\\u{50000}-\\u{5FFFD}\\u{60000-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}]/u,\n  // /[\\u{90000}-\\u{9FFFD}\\u{A0000-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}]/u,\n  // /[\\u{D0000}-\\u{DFFFD}\\u{E0000-\\u{EFFFD}]/u\n);\n\n// Valid characters for identifiers.\nconst identifierCharacter = either(\n  identifierHead,\n  /\\d/,\n  /[\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]/\n);\n\n// Valid identifier.\nconst identifier = concat(identifierHead, identifierCharacter, '*');\n\n// Valid type identifier.\nconst typeIdentifier = concat(/[A-Z]/, identifierCharacter, '*');\n\n// Built-in attributes, which are highlighted as keywords.\n// @available is handled separately.\nconst keywordAttributes = [\n  'autoclosure',\n  concat(/convention\\(/, either('swift', 'block', 'c'), /\\)/),\n  'discardableResult',\n  'dynamicCallable',\n  'dynamicMemberLookup',\n  'escaping',\n  'frozen',\n  'GKInspectable',\n  'IBAction',\n  'IBDesignable',\n  'IBInspectable',\n  'IBOutlet',\n  'IBSegueAction',\n  'inlinable',\n  'main',\n  'nonobjc',\n  'NSApplicationMain',\n  'NSCopying',\n  'NSManaged',\n  concat(/objc\\(/, identifier, /\\)/),\n  'objc',\n  'objcMembers',\n  'propertyWrapper',\n  'requires_stored_property_inits',\n  'resultBuilder',\n  'testable',\n  'UIApplicationMain',\n  'unknown',\n  'usableFromInline'\n];\n\n// Contextual keywords used in @available and #available.\nconst availabilityKeywords = [\n  'iOS',\n  'iOSApplicationExtension',\n  'macOS',\n  'macOSApplicationExtension',\n  'macCatalyst',\n  'macCatalystApplicationExtension',\n  'watchOS',\n  'watchOSApplicationExtension',\n  'tvOS',\n  'tvOSApplicationExtension',\n  'swift'\n];\n\n/*\nLanguage: Swift\nDescription: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.\nAuthor: Steven Van Impe <steven.vanimpe@icloud.com>\nContributors: Chris Eidhof <chris@eidhof.nl>, Nate Cook <natecook@gmail.com>, Alexander Lichter <manniL@gmx.net>, Richard Gibson <gibson042@github>\nWebsite: https://swift.org\nCategory: common, system\n*/\n\n/** @type LanguageFn */\nfunction swift(hljs) {\n  const WHITESPACE = {\n    match: /\\s+/,\n    relevance: 0\n  };\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411\n  const BLOCK_COMMENT = hljs.COMMENT(\n    '/\\\\*',\n    '\\\\*/',\n    {\n      contains: [ 'self' ]\n    }\n  );\n  const COMMENTS = [\n    hljs.C_LINE_COMMENT_MODE,\n    BLOCK_COMMENT\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413\n  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html\n  const DOT_KEYWORD = {\n    match: [\n      /\\./,\n      either(...dotKeywords, ...optionalDotKeywords)\n    ],\n    className: {\n      2: \"keyword\"\n    }\n  };\n  const KEYWORD_GUARD = {\n    // Consume .keyword to prevent highlighting properties and methods as keywords.\n    match: concat(/\\./, either(...keywords)),\n    relevance: 0\n  };\n  const PLAIN_KEYWORDS = keywords\n    .filter(kw => typeof kw === 'string')\n    .concat([ \"_|0\" ]); // seems common, so 0 relevance\n  const REGEX_KEYWORDS = keywords\n    .filter(kw => typeof kw !== 'string') // find regex\n    .concat(keywordTypes)\n    .map(keywordWrapper);\n  const KEYWORD = {\n    variants: [\n      {\n        className: 'keyword',\n        match: either(...REGEX_KEYWORDS, ...optionalDotKeywords)\n      }\n    ]\n  };\n  // find all the regular keywords\n  const KEYWORDS = {\n    $pattern: either(\n      /\\b\\w+/, // regular keywords\n      /#\\w+/ // number keywords\n    ),\n    keyword: PLAIN_KEYWORDS\n      .concat(numberSignKeywords),\n    literal: literals\n  };\n  const KEYWORD_MODES = [\n    DOT_KEYWORD,\n    KEYWORD_GUARD,\n    KEYWORD\n  ];\n\n  // https://github.com/apple/swift/tree/main/stdlib/public/core\n  const BUILT_IN_GUARD = {\n    // Consume .built_in to prevent highlighting properties and methods.\n    match: concat(/\\./, either(...builtIns)),\n    relevance: 0\n  };\n  const BUILT_IN = {\n    className: 'built_in',\n    match: concat(/\\b/, either(...builtIns), /(?=\\()/)\n  };\n  const BUILT_INS = [\n    BUILT_IN_GUARD,\n    BUILT_IN\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418\n  const OPERATOR_GUARD = {\n    // Prevent -> from being highlighting as an operator.\n    match: /->/,\n    relevance: 0\n  };\n  const OPERATOR = {\n    className: 'operator',\n    relevance: 0,\n    variants: [\n      {\n        match: operator\n      },\n      {\n        // dot-operator: only operators that start with a dot are allowed to use dots as\n        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more\n        // characters that may also include dots.\n        match: `\\\\.(\\\\.|${operatorCharacter})+`\n      }\n    ]\n  };\n  const OPERATORS = [\n    OPERATOR_GUARD,\n    OPERATOR\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal\n  // TODO: Update for leading `-` after lookbehind is supported everywhere\n  const decimalDigits = '([0-9]_*)+';\n  const hexDigits = '([0-9a-fA-F]_*)+';\n  const NUMBER = {\n    className: 'number',\n    relevance: 0,\n    variants: [\n      // decimal floating-point-literal (subsumes decimal-literal)\n      {\n        match: `\\\\b(${decimalDigits})(\\\\.(${decimalDigits}))?` + `([eE][+-]?(${decimalDigits}))?\\\\b`\n      },\n      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)\n      {\n        match: `\\\\b0x(${hexDigits})(\\\\.(${hexDigits}))?` + `([pP][+-]?(${decimalDigits}))?\\\\b`\n      },\n      // octal-literal\n      {\n        match: /\\b0o([0-7]_*)+\\b/\n      },\n      // binary-literal\n      {\n        match: /\\b0b([01]_*)+\\b/\n      }\n    ]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal\n  const ESCAPED_CHARACTER = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    variants: [\n      {\n        match: concat(/\\\\/, rawDelimiter, /[0\\\\tnr\"']/)\n      },\n      {\n        match: concat(/\\\\/, rawDelimiter, /u\\{[0-9a-fA-F]{1,8}\\}/)\n      }\n    ]\n  });\n  const ESCAPED_NEWLINE = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    match: concat(/\\\\/, rawDelimiter, /[\\t ]*(?:[\\r\\n]|\\r\\n)/)\n  });\n  const INTERPOLATION = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    label: \"interpol\",\n    begin: concat(/\\\\/, rawDelimiter, /\\(/),\n    end: /\\)/\n  });\n  const MULTILINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"\"\"/),\n    end: concat(/\"\"\"/, rawDelimiter),\n    contains: [\n      ESCAPED_CHARACTER(rawDelimiter),\n      ESCAPED_NEWLINE(rawDelimiter),\n      INTERPOLATION(rawDelimiter)\n    ]\n  });\n  const SINGLE_LINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"/),\n    end: concat(/\"/, rawDelimiter),\n    contains: [\n      ESCAPED_CHARACTER(rawDelimiter),\n      INTERPOLATION(rawDelimiter)\n    ]\n  });\n  const STRING = {\n    className: 'string',\n    variants: [\n      MULTILINE_STRING(),\n      MULTILINE_STRING(\"#\"),\n      MULTILINE_STRING(\"##\"),\n      MULTILINE_STRING(\"###\"),\n      SINGLE_LINE_STRING(),\n      SINGLE_LINE_STRING(\"#\"),\n      SINGLE_LINE_STRING(\"##\"),\n      SINGLE_LINE_STRING(\"###\")\n    ]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412\n  const QUOTED_IDENTIFIER = {\n    match: concat(/`/, identifier, /`/)\n  };\n  const IMPLICIT_PARAMETER = {\n    className: 'variable',\n    match: /\\$\\d+/\n  };\n  const PROPERTY_WRAPPER_PROJECTION = {\n    className: 'variable',\n    match: `\\\\$${identifierCharacter}+`\n  };\n  const IDENTIFIERS = [\n    QUOTED_IDENTIFIER,\n    IMPLICIT_PARAMETER,\n    PROPERTY_WRAPPER_PROJECTION\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html\n  const AVAILABLE_ATTRIBUTE = {\n    match: /(@|#)available/,\n    className: \"keyword\",\n    starts: {\n      contains: [\n        {\n          begin: /\\(/,\n          end: /\\)/,\n          keywords: availabilityKeywords,\n          contains: [\n            ...OPERATORS,\n            NUMBER,\n            STRING\n          ]\n        }\n      ]\n    }\n  };\n  const KEYWORD_ATTRIBUTE = {\n    className: 'keyword',\n    match: concat(/@/, either(...keywordAttributes))\n  };\n  const USER_DEFINED_ATTRIBUTE = {\n    className: 'meta',\n    match: concat(/@/, identifier)\n  };\n  const ATTRIBUTES = [\n    AVAILABLE_ATTRIBUTE,\n    KEYWORD_ATTRIBUTE,\n    USER_DEFINED_ATTRIBUTE\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Types.html\n  const TYPE = {\n    match: lookahead(/\\b[A-Z]/),\n    relevance: 0,\n    contains: [\n      { // Common Apple frameworks, for relevance boost\n        className: 'type',\n        match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, '+')\n      },\n      { // Type identifier\n        className: 'type',\n        match: typeIdentifier,\n        relevance: 0\n      },\n      { // Optional type\n        match: /[?!]+/,\n        relevance: 0\n      },\n      { // Variadic parameter\n        match: /\\.\\.\\./,\n        relevance: 0\n      },\n      { // Protocol composition\n        match: concat(/\\s+&\\s+/, lookahead(typeIdentifier)),\n        relevance: 0\n      }\n    ]\n  };\n  const GENERIC_ARGUMENTS = {\n    begin: /</,\n    end: />/,\n    keywords: KEYWORDS,\n    contains: [\n      ...COMMENTS,\n      ...KEYWORD_MODES,\n      ...ATTRIBUTES,\n      OPERATOR_GUARD,\n      TYPE\n    ]\n  };\n  TYPE.contains.push(GENERIC_ARGUMENTS);\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#ID552\n  // Prevents element names from being highlighted as keywords.\n  const TUPLE_ELEMENT_NAME = {\n    match: concat(identifier, /\\s*:/),\n    keywords: \"_|0\",\n    relevance: 0\n  };\n  // Matches tuples as well as the parameter list of a function type.\n  const TUPLE = {\n    begin: /\\(/,\n    end: /\\)/,\n    relevance: 0,\n    keywords: KEYWORDS,\n    contains: [\n      'self',\n      TUPLE_ELEMENT_NAME,\n      ...COMMENTS,\n      ...KEYWORD_MODES,\n      ...BUILT_INS,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...IDENTIFIERS,\n      ...ATTRIBUTES,\n      TYPE\n    ]\n  };\n\n  const GENERIC_PARAMETERS = {\n    begin: /</,\n    end: />/,\n    contains: [\n      ...COMMENTS,\n      TYPE\n    ]\n  };\n  const FUNCTION_PARAMETER_NAME = {\n    begin: either(\n      lookahead(concat(identifier, /\\s*:/)),\n      lookahead(concat(identifier, /\\s+/, identifier, /\\s*:/))\n    ),\n    end: /:/,\n    relevance: 0,\n    contains: [\n      {\n        className: 'keyword',\n        match: /\\b_\\b/\n      },\n      {\n        className: 'params',\n        match: identifier\n      }\n    ]\n  };\n  const FUNCTION_PARAMETERS = {\n    begin: /\\(/,\n    end: /\\)/,\n    keywords: KEYWORDS,\n    contains: [\n      FUNCTION_PARAMETER_NAME,\n      ...COMMENTS,\n      ...KEYWORD_MODES,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...ATTRIBUTES,\n      TYPE,\n      TUPLE\n    ],\n    endsParent: true,\n    illegal: /[\"']/\n  };\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID362\n  const FUNCTION = {\n    match: [\n      /func/,\n      /\\s+/,\n      either(QUOTED_IDENTIFIER.match, identifier, operator)\n    ],\n    className: {\n      1: \"keyword\",\n      3: \"title.function\"\n    },\n    contains: [\n      GENERIC_PARAMETERS,\n      FUNCTION_PARAMETERS,\n      WHITESPACE\n    ],\n    illegal: [\n      /\\[/,\n      /%/\n    ]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID375\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID379\n  const INIT_SUBSCRIPT = {\n    match: [\n      /\\b(?:subscript|init[?!]?)/,\n      /\\s*(?=[<(])/,\n    ],\n    className: {\n      1: \"keyword\"\n    },\n    contains: [\n      GENERIC_PARAMETERS,\n      FUNCTION_PARAMETERS,\n      WHITESPACE\n    ],\n    illegal: /\\[|%/\n  };\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID380\n  const OPERATOR_DECLARATION = {\n    match: [\n      /operator/,\n      /\\s+/,\n      operator\n    ],\n    className: {\n      1: \"keyword\",\n      3: \"title\"\n    }\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID550\n  const PRECEDENCEGROUP = {\n    begin: [\n      /precedencegroup/,\n      /\\s+/,\n      typeIdentifier\n    ],\n    className: {\n      1: \"keyword\",\n      3: \"title\"\n    },\n    contains: [ TYPE ],\n    keywords: [\n      ...precedencegroupKeywords,\n      ...literals\n    ],\n    end: /}/\n  };\n\n  // Add supported submodes to string interpolation.\n  for (const variant of STRING.variants) {\n    const interpolation = variant.contains.find(mode => mode.label === \"interpol\");\n    // TODO: Interpolation can contain any expression, so there's room for improvement here.\n    interpolation.keywords = KEYWORDS;\n    const submodes = [\n      ...KEYWORD_MODES,\n      ...BUILT_INS,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...IDENTIFIERS\n    ];\n    interpolation.contains = [\n      ...submodes,\n      {\n        begin: /\\(/,\n        end: /\\)/,\n        contains: [\n          'self',\n          ...submodes\n        ]\n      }\n    ];\n  }\n\n  return {\n    name: 'Swift',\n    keywords: KEYWORDS,\n    contains: [\n      ...COMMENTS,\n      FUNCTION,\n      INIT_SUBSCRIPT,\n      {\n        beginKeywords: 'struct protocol class extension enum actor',\n        end: '\\\\{',\n        excludeEnd: true,\n        keywords: KEYWORDS,\n        contains: [\n          hljs.inherit(hljs.TITLE_MODE, {\n            className: \"title.class\",\n            begin: /[A-Za-z$_][\\u00C0-\\u02B80-9A-Za-z$_]*/\n          }),\n          ...KEYWORD_MODES\n        ]\n      },\n      OPERATOR_DECLARATION,\n      PRECEDENCEGROUP,\n      {\n        beginKeywords: 'import',\n        end: /$/,\n        contains: [ ...COMMENTS ],\n        relevance: 0\n      },\n      ...KEYWORD_MODES,\n      ...BUILT_INS,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...IDENTIFIERS,\n      ...ATTRIBUTES,\n      TYPE,\n      TUPLE\n    ]\n  };\n}\n\nmodule.exports = swift;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["variants","begin","className","label","contains","$pattern","relevance","name","endsParent","keyword","keywords","beginKeywords","match","starts","excludeEnd","illegal","literal","end"]],"~:compiled-at",1668750081696,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$highlight_DOT_js$lib$languages$swift.js\",\n\"lineCount\":25,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/highlight_DOT_js/lib/languages/swift.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$highlight_DOT_js$lib$languages$swift\\\"] = function(global,require,module,exports) {\\n/**\\n * @param {string} value\\n * @returns {RegExp}\\n * */\\n\\n/**\\n * @param {RegExp | string } re\\n * @returns {string}\\n */\\nfunction source(re) {\\n  if (!re) return null;\\n  if (typeof re === \\\"string\\\") return re;\\n\\n  return re.source;\\n}\\n\\n/**\\n * @param {RegExp | string } re\\n * @returns {string}\\n */\\nfunction lookahead(re) {\\n  return concat('(?=', re, ')');\\n}\\n\\n/**\\n * @param {...(RegExp | string) } args\\n * @returns {string}\\n */\\nfunction concat(...args) {\\n  const joined = args.map((x) => source(x)).join(\\\"\\\");\\n  return joined;\\n}\\n\\nfunction stripOptionsFromArgs(args) {\\n  const opts = args[args.length - 1];\\n\\n  if (typeof opts === 'object' && opts.constructor === Object) {\\n    args.splice(args.length - 1, 1);\\n    return opts;\\n  } else {\\n    return {};\\n  }\\n}\\n\\n/**\\n * Any of the passed expresssions may match\\n *\\n * Creates a huge this | this | that | that match\\n * @param {(RegExp | string)[] } args\\n * @returns {string}\\n */\\nfunction either(...args) {\\n  const opts = stripOptionsFromArgs(args);\\n  const joined = '(' +\\n    (opts.capture ? \\\"\\\" : \\\"?:\\\") +\\n    args.map((x) => source(x)).join(\\\"|\\\") + \\\")\\\";\\n  return joined;\\n}\\n\\nconst keywordWrapper = keyword => concat(\\n  /\\\\b/,\\n  keyword,\\n  /\\\\w$/.test(keyword) ? /\\\\b/ : /\\\\B/\\n);\\n\\n// Keywords that require a leading dot.\\nconst dotKeywords = [\\n  'Protocol', // contextual\\n  'Type' // contextual\\n].map(keywordWrapper);\\n\\n// Keywords that may have a leading dot.\\nconst optionalDotKeywords = [\\n  'init',\\n  'self'\\n].map(keywordWrapper);\\n\\n// should register as keyword, not type\\nconst keywordTypes = [\\n  'Any',\\n  'Self'\\n];\\n\\n// Regular keywords and literals.\\nconst keywords = [\\n  // strings below will be fed into the regular `keywords` engine while regex\\n  // will result in additional modes being created to scan for those keywords to\\n  // avoid conflicts with other rules\\n  'actor',\\n  'associatedtype',\\n  'async',\\n  'await',\\n  /as\\\\?/, // operator\\n  /as!/, // operator\\n  'as', // operator\\n  'break',\\n  'case',\\n  'catch',\\n  'class',\\n  'continue',\\n  'convenience', // contextual\\n  'default',\\n  'defer',\\n  'deinit',\\n  'didSet', // contextual\\n  'do',\\n  'dynamic', // contextual\\n  'else',\\n  'enum',\\n  'extension',\\n  'fallthrough',\\n  /fileprivate\\\\(set\\\\)/,\\n  'fileprivate',\\n  'final', // contextual\\n  'for',\\n  'func',\\n  'get', // contextual\\n  'guard',\\n  'if',\\n  'import',\\n  'indirect', // contextual\\n  'infix', // contextual\\n  /init\\\\?/,\\n  /init!/,\\n  'inout',\\n  /internal\\\\(set\\\\)/,\\n  'internal',\\n  'in',\\n  'is', // operator\\n  'lazy', // contextual\\n  'let',\\n  'mutating', // contextual\\n  'nonmutating', // contextual\\n  /open\\\\(set\\\\)/, // contextual\\n  'open', // contextual\\n  'operator',\\n  'optional', // contextual\\n  'override', // contextual\\n  'postfix', // contextual\\n  'precedencegroup',\\n  'prefix', // contextual\\n  /private\\\\(set\\\\)/,\\n  'private',\\n  'protocol',\\n  /public\\\\(set\\\\)/,\\n  'public',\\n  'repeat',\\n  'required', // contextual\\n  'rethrows',\\n  'return',\\n  'set', // contextual\\n  'some', // contextual\\n  'static',\\n  'struct',\\n  'subscript',\\n  'super',\\n  'switch',\\n  'throws',\\n  'throw',\\n  /try\\\\?/, // operator\\n  /try!/, // operator\\n  'try', // operator\\n  'typealias',\\n  /unowned\\\\(safe\\\\)/, // contextual\\n  /unowned\\\\(unsafe\\\\)/, // contextual\\n  'unowned', // contextual\\n  'var',\\n  'weak', // contextual\\n  'where',\\n  'while',\\n  'willSet' // contextual\\n];\\n\\n// NOTE: Contextual keywords are reserved only in specific contexts.\\n// Ideally, these should be matched using modes to avoid false positives.\\n\\n// Literals.\\nconst literals = [\\n  'false',\\n  'nil',\\n  'true'\\n];\\n\\n// Keywords used in precedence groups.\\nconst precedencegroupKeywords = [\\n  'assignment',\\n  'associativity',\\n  'higherThan',\\n  'left',\\n  'lowerThan',\\n  'none',\\n  'right'\\n];\\n\\n// Keywords that start with a number sign (#).\\n// #available is handled separately.\\nconst numberSignKeywords = [\\n  '#colorLiteral',\\n  '#column',\\n  '#dsohandle',\\n  '#else',\\n  '#elseif',\\n  '#endif',\\n  '#error',\\n  '#file',\\n  '#fileID',\\n  '#fileLiteral',\\n  '#filePath',\\n  '#function',\\n  '#if',\\n  '#imageLiteral',\\n  '#keyPath',\\n  '#line',\\n  '#selector',\\n  '#sourceLocation',\\n  '#warn_unqualified_access',\\n  '#warning'\\n];\\n\\n// Global functions in the Standard Library.\\nconst builtIns = [\\n  'abs',\\n  'all',\\n  'any',\\n  'assert',\\n  'assertionFailure',\\n  'debugPrint',\\n  'dump',\\n  'fatalError',\\n  'getVaList',\\n  'isKnownUniquelyReferenced',\\n  'max',\\n  'min',\\n  'numericCast',\\n  'pointwiseMax',\\n  'pointwiseMin',\\n  'precondition',\\n  'preconditionFailure',\\n  'print',\\n  'readLine',\\n  'repeatElement',\\n  'sequence',\\n  'stride',\\n  'swap',\\n  'swift_unboxFromSwiftValueWithType',\\n  'transcode',\\n  'type',\\n  'unsafeBitCast',\\n  'unsafeDowncast',\\n  'withExtendedLifetime',\\n  'withUnsafeMutablePointer',\\n  'withUnsafePointer',\\n  'withVaList',\\n  'withoutActuallyEscaping',\\n  'zip'\\n];\\n\\n// Valid first characters for operators.\\nconst operatorHead = either(\\n  /[/=\\\\-+!*%<>&|^~?]/,\\n  /[\\\\u00A1-\\\\u00A7]/,\\n  /[\\\\u00A9\\\\u00AB]/,\\n  /[\\\\u00AC\\\\u00AE]/,\\n  /[\\\\u00B0\\\\u00B1]/,\\n  /[\\\\u00B6\\\\u00BB\\\\u00BF\\\\u00D7\\\\u00F7]/,\\n  /[\\\\u2016-\\\\u2017]/,\\n  /[\\\\u2020-\\\\u2027]/,\\n  /[\\\\u2030-\\\\u203E]/,\\n  /[\\\\u2041-\\\\u2053]/,\\n  /[\\\\u2055-\\\\u205E]/,\\n  /[\\\\u2190-\\\\u23FF]/,\\n  /[\\\\u2500-\\\\u2775]/,\\n  /[\\\\u2794-\\\\u2BFF]/,\\n  /[\\\\u2E00-\\\\u2E7F]/,\\n  /[\\\\u3001-\\\\u3003]/,\\n  /[\\\\u3008-\\\\u3020]/,\\n  /[\\\\u3030]/\\n);\\n\\n// Valid characters for operators.\\nconst operatorCharacter = either(\\n  operatorHead,\\n  /[\\\\u0300-\\\\u036F]/,\\n  /[\\\\u1DC0-\\\\u1DFF]/,\\n  /[\\\\u20D0-\\\\u20FF]/,\\n  /[\\\\uFE00-\\\\uFE0F]/,\\n  /[\\\\uFE20-\\\\uFE2F]/\\n  // TODO: The following characters are also allowed, but the regex isn't supported yet.\\n  // /[\\\\u{E0100}-\\\\u{E01EF}]/u\\n);\\n\\n// Valid operator.\\nconst operator = concat(operatorHead, operatorCharacter, '*');\\n\\n// Valid first characters for identifiers.\\nconst identifierHead = either(\\n  /[a-zA-Z_]/,\\n  /[\\\\u00A8\\\\u00AA\\\\u00AD\\\\u00AF\\\\u00B2-\\\\u00B5\\\\u00B7-\\\\u00BA]/,\\n  /[\\\\u00BC-\\\\u00BE\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u00FF]/,\\n  /[\\\\u0100-\\\\u02FF\\\\u0370-\\\\u167F\\\\u1681-\\\\u180D\\\\u180F-\\\\u1DBF]/,\\n  /[\\\\u1E00-\\\\u1FFF]/,\\n  /[\\\\u200B-\\\\u200D\\\\u202A-\\\\u202E\\\\u203F-\\\\u2040\\\\u2054\\\\u2060-\\\\u206F]/,\\n  /[\\\\u2070-\\\\u20CF\\\\u2100-\\\\u218F\\\\u2460-\\\\u24FF\\\\u2776-\\\\u2793]/,\\n  /[\\\\u2C00-\\\\u2DFF\\\\u2E80-\\\\u2FFF]/,\\n  /[\\\\u3004-\\\\u3007\\\\u3021-\\\\u302F\\\\u3031-\\\\u303F\\\\u3040-\\\\uD7FF]/,\\n  /[\\\\uF900-\\\\uFD3D\\\\uFD40-\\\\uFDCF\\\\uFDF0-\\\\uFE1F\\\\uFE30-\\\\uFE44]/,\\n  /[\\\\uFE47-\\\\uFEFE\\\\uFF00-\\\\uFFFD]/ // Should be /[\\\\uFE47-\\\\uFFFD]/, but we have to exclude FEFF.\\n  // The following characters are also allowed, but the regexes aren't supported yet.\\n  // /[\\\\u{10000}-\\\\u{1FFFD}\\\\u{20000-\\\\u{2FFFD}\\\\u{30000}-\\\\u{3FFFD}\\\\u{40000}-\\\\u{4FFFD}]/u,\\n  // /[\\\\u{50000}-\\\\u{5FFFD}\\\\u{60000-\\\\u{6FFFD}\\\\u{70000}-\\\\u{7FFFD}\\\\u{80000}-\\\\u{8FFFD}]/u,\\n  // /[\\\\u{90000}-\\\\u{9FFFD}\\\\u{A0000-\\\\u{AFFFD}\\\\u{B0000}-\\\\u{BFFFD}\\\\u{C0000}-\\\\u{CFFFD}]/u,\\n  // /[\\\\u{D0000}-\\\\u{DFFFD}\\\\u{E0000-\\\\u{EFFFD}]/u\\n);\\n\\n// Valid characters for identifiers.\\nconst identifierCharacter = either(\\n  identifierHead,\\n  /\\\\d/,\\n  /[\\\\u0300-\\\\u036F\\\\u1DC0-\\\\u1DFF\\\\u20D0-\\\\u20FF\\\\uFE20-\\\\uFE2F]/\\n);\\n\\n// Valid identifier.\\nconst identifier = concat(identifierHead, identifierCharacter, '*');\\n\\n// Valid type identifier.\\nconst typeIdentifier = concat(/[A-Z]/, identifierCharacter, '*');\\n\\n// Built-in attributes, which are highlighted as keywords.\\n// @available is handled separately.\\nconst keywordAttributes = [\\n  'autoclosure',\\n  concat(/convention\\\\(/, either('swift', 'block', 'c'), /\\\\)/),\\n  'discardableResult',\\n  'dynamicCallable',\\n  'dynamicMemberLookup',\\n  'escaping',\\n  'frozen',\\n  'GKInspectable',\\n  'IBAction',\\n  'IBDesignable',\\n  'IBInspectable',\\n  'IBOutlet',\\n  'IBSegueAction',\\n  'inlinable',\\n  'main',\\n  'nonobjc',\\n  'NSApplicationMain',\\n  'NSCopying',\\n  'NSManaged',\\n  concat(/objc\\\\(/, identifier, /\\\\)/),\\n  'objc',\\n  'objcMembers',\\n  'propertyWrapper',\\n  'requires_stored_property_inits',\\n  'resultBuilder',\\n  'testable',\\n  'UIApplicationMain',\\n  'unknown',\\n  'usableFromInline'\\n];\\n\\n// Contextual keywords used in @available and #available.\\nconst availabilityKeywords = [\\n  'iOS',\\n  'iOSApplicationExtension',\\n  'macOS',\\n  'macOSApplicationExtension',\\n  'macCatalyst',\\n  'macCatalystApplicationExtension',\\n  'watchOS',\\n  'watchOSApplicationExtension',\\n  'tvOS',\\n  'tvOSApplicationExtension',\\n  'swift'\\n];\\n\\n/*\\nLanguage: Swift\\nDescription: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.\\nAuthor: Steven Van Impe <steven.vanimpe@icloud.com>\\nContributors: Chris Eidhof <chris@eidhof.nl>, Nate Cook <natecook@gmail.com>, Alexander Lichter <manniL@gmx.net>, Richard Gibson <gibson042@github>\\nWebsite: https://swift.org\\nCategory: common, system\\n*/\\n\\n/** @type LanguageFn */\\nfunction swift(hljs) {\\n  const WHITESPACE = {\\n    match: /\\\\s+/,\\n    relevance: 0\\n  };\\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411\\n  const BLOCK_COMMENT = hljs.COMMENT(\\n    '/\\\\\\\\*',\\n    '\\\\\\\\*/',\\n    {\\n      contains: [ 'self' ]\\n    }\\n  );\\n  const COMMENTS = [\\n    hljs.C_LINE_COMMENT_MODE,\\n    BLOCK_COMMENT\\n  ];\\n\\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413\\n  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html\\n  const DOT_KEYWORD = {\\n    match: [\\n      /\\\\./,\\n      either(...dotKeywords, ...optionalDotKeywords)\\n    ],\\n    className: {\\n      2: \\\"keyword\\\"\\n    }\\n  };\\n  const KEYWORD_GUARD = {\\n    // Consume .keyword to prevent highlighting properties and methods as keywords.\\n    match: concat(/\\\\./, either(...keywords)),\\n    relevance: 0\\n  };\\n  const PLAIN_KEYWORDS = keywords\\n    .filter(kw => typeof kw === 'string')\\n    .concat([ \\\"_|0\\\" ]); // seems common, so 0 relevance\\n  const REGEX_KEYWORDS = keywords\\n    .filter(kw => typeof kw !== 'string') // find regex\\n    .concat(keywordTypes)\\n    .map(keywordWrapper);\\n  const KEYWORD = {\\n    variants: [\\n      {\\n        className: 'keyword',\\n        match: either(...REGEX_KEYWORDS, ...optionalDotKeywords)\\n      }\\n    ]\\n  };\\n  // find all the regular keywords\\n  const KEYWORDS = {\\n    $pattern: either(\\n      /\\\\b\\\\w+/, // regular keywords\\n      /#\\\\w+/ // number keywords\\n    ),\\n    keyword: PLAIN_KEYWORDS\\n      .concat(numberSignKeywords),\\n    literal: literals\\n  };\\n  const KEYWORD_MODES = [\\n    DOT_KEYWORD,\\n    KEYWORD_GUARD,\\n    KEYWORD\\n  ];\\n\\n  // https://github.com/apple/swift/tree/main/stdlib/public/core\\n  const BUILT_IN_GUARD = {\\n    // Consume .built_in to prevent highlighting properties and methods.\\n    match: concat(/\\\\./, either(...builtIns)),\\n    relevance: 0\\n  };\\n  const BUILT_IN = {\\n    className: 'built_in',\\n    match: concat(/\\\\b/, either(...builtIns), /(?=\\\\()/)\\n  };\\n  const BUILT_INS = [\\n    BUILT_IN_GUARD,\\n    BUILT_IN\\n  ];\\n\\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418\\n  const OPERATOR_GUARD = {\\n    // Prevent -> from being highlighting as an operator.\\n    match: /->/,\\n    relevance: 0\\n  };\\n  const OPERATOR = {\\n    className: 'operator',\\n    relevance: 0,\\n    variants: [\\n      {\\n        match: operator\\n      },\\n      {\\n        // dot-operator: only operators that start with a dot are allowed to use dots as\\n        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more\\n        // characters that may also include dots.\\n        match: `\\\\\\\\.(\\\\\\\\.|${operatorCharacter})+`\\n      }\\n    ]\\n  };\\n  const OPERATORS = [\\n    OPERATOR_GUARD,\\n    OPERATOR\\n  ];\\n\\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal\\n  // TODO: Update for leading `-` after lookbehind is supported everywhere\\n  const decimalDigits = '([0-9]_*)+';\\n  const hexDigits = '([0-9a-fA-F]_*)+';\\n  const NUMBER = {\\n    className: 'number',\\n    relevance: 0,\\n    variants: [\\n      // decimal floating-point-literal (subsumes decimal-literal)\\n      {\\n        match: `\\\\\\\\b(${decimalDigits})(\\\\\\\\.(${decimalDigits}))?` + `([eE][+-]?(${decimalDigits}))?\\\\\\\\b`\\n      },\\n      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)\\n      {\\n        match: `\\\\\\\\b0x(${hexDigits})(\\\\\\\\.(${hexDigits}))?` + `([pP][+-]?(${decimalDigits}))?\\\\\\\\b`\\n      },\\n      // octal-literal\\n      {\\n        match: /\\\\b0o([0-7]_*)+\\\\b/\\n      },\\n      // binary-literal\\n      {\\n        match: /\\\\b0b([01]_*)+\\\\b/\\n      }\\n    ]\\n  };\\n\\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal\\n  const ESCAPED_CHARACTER = (rawDelimiter = \\\"\\\") => ({\\n    className: 'subst',\\n    variants: [\\n      {\\n        match: concat(/\\\\\\\\/, rawDelimiter, /[0\\\\\\\\tnr\\\"']/)\\n      },\\n      {\\n        match: concat(/\\\\\\\\/, rawDelimiter, /u\\\\{[0-9a-fA-F]{1,8}\\\\}/)\\n      }\\n    ]\\n  });\\n  const ESCAPED_NEWLINE = (rawDelimiter = \\\"\\\") => ({\\n    className: 'subst',\\n    match: concat(/\\\\\\\\/, rawDelimiter, /[\\\\t ]*(?:[\\\\r\\\\n]|\\\\r\\\\n)/)\\n  });\\n  const INTERPOLATION = (rawDelimiter = \\\"\\\") => ({\\n    className: 'subst',\\n    label: \\\"interpol\\\",\\n    begin: concat(/\\\\\\\\/, rawDelimiter, /\\\\(/),\\n    end: /\\\\)/\\n  });\\n  const MULTILINE_STRING = (rawDelimiter = \\\"\\\") => ({\\n    begin: concat(rawDelimiter, /\\\"\\\"\\\"/),\\n    end: concat(/\\\"\\\"\\\"/, rawDelimiter),\\n    contains: [\\n      ESCAPED_CHARACTER(rawDelimiter),\\n      ESCAPED_NEWLINE(rawDelimiter),\\n      INTERPOLATION(rawDelimiter)\\n    ]\\n  });\\n  const SINGLE_LINE_STRING = (rawDelimiter = \\\"\\\") => ({\\n    begin: concat(rawDelimiter, /\\\"/),\\n    end: concat(/\\\"/, rawDelimiter),\\n    contains: [\\n      ESCAPED_CHARACTER(rawDelimiter),\\n      INTERPOLATION(rawDelimiter)\\n    ]\\n  });\\n  const STRING = {\\n    className: 'string',\\n    variants: [\\n      MULTILINE_STRING(),\\n      MULTILINE_STRING(\\\"#\\\"),\\n      MULTILINE_STRING(\\\"##\\\"),\\n      MULTILINE_STRING(\\\"###\\\"),\\n      SINGLE_LINE_STRING(),\\n      SINGLE_LINE_STRING(\\\"#\\\"),\\n      SINGLE_LINE_STRING(\\\"##\\\"),\\n      SINGLE_LINE_STRING(\\\"###\\\")\\n    ]\\n  };\\n\\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412\\n  const QUOTED_IDENTIFIER = {\\n    match: concat(/`/, identifier, /`/)\\n  };\\n  const IMPLICIT_PARAMETER = {\\n    className: 'variable',\\n    match: /\\\\$\\\\d+/\\n  };\\n  const PROPERTY_WRAPPER_PROJECTION = {\\n    className: 'variable',\\n    match: `\\\\\\\\$${identifierCharacter}+`\\n  };\\n  const IDENTIFIERS = [\\n    QUOTED_IDENTIFIER,\\n    IMPLICIT_PARAMETER,\\n    PROPERTY_WRAPPER_PROJECTION\\n  ];\\n\\n  // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html\\n  const AVAILABLE_ATTRIBUTE = {\\n    match: /(@|#)available/,\\n    className: \\\"keyword\\\",\\n    starts: {\\n      contains: [\\n        {\\n          begin: /\\\\(/,\\n          end: /\\\\)/,\\n          keywords: availabilityKeywords,\\n          contains: [\\n            ...OPERATORS,\\n            NUMBER,\\n            STRING\\n          ]\\n        }\\n      ]\\n    }\\n  };\\n  const KEYWORD_ATTRIBUTE = {\\n    className: 'keyword',\\n    match: concat(/@/, either(...keywordAttributes))\\n  };\\n  const USER_DEFINED_ATTRIBUTE = {\\n    className: 'meta',\\n    match: concat(/@/, identifier)\\n  };\\n  const ATTRIBUTES = [\\n    AVAILABLE_ATTRIBUTE,\\n    KEYWORD_ATTRIBUTE,\\n    USER_DEFINED_ATTRIBUTE\\n  ];\\n\\n  // https://docs.swift.org/swift-book/ReferenceManual/Types.html\\n  const TYPE = {\\n    match: lookahead(/\\\\b[A-Z]/),\\n    relevance: 0,\\n    contains: [\\n      { // Common Apple frameworks, for relevance boost\\n        className: 'type',\\n        match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, '+')\\n      },\\n      { // Type identifier\\n        className: 'type',\\n        match: typeIdentifier,\\n        relevance: 0\\n      },\\n      { // Optional type\\n        match: /[?!]+/,\\n        relevance: 0\\n      },\\n      { // Variadic parameter\\n        match: /\\\\.\\\\.\\\\./,\\n        relevance: 0\\n      },\\n      { // Protocol composition\\n        match: concat(/\\\\s+&\\\\s+/, lookahead(typeIdentifier)),\\n        relevance: 0\\n      }\\n    ]\\n  };\\n  const GENERIC_ARGUMENTS = {\\n    begin: /</,\\n    end: />/,\\n    keywords: KEYWORDS,\\n    contains: [\\n      ...COMMENTS,\\n      ...KEYWORD_MODES,\\n      ...ATTRIBUTES,\\n      OPERATOR_GUARD,\\n      TYPE\\n    ]\\n  };\\n  TYPE.contains.push(GENERIC_ARGUMENTS);\\n\\n  // https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#ID552\\n  // Prevents element names from being highlighted as keywords.\\n  const TUPLE_ELEMENT_NAME = {\\n    match: concat(identifier, /\\\\s*:/),\\n    keywords: \\\"_|0\\\",\\n    relevance: 0\\n  };\\n  // Matches tuples as well as the parameter list of a function type.\\n  const TUPLE = {\\n    begin: /\\\\(/,\\n    end: /\\\\)/,\\n    relevance: 0,\\n    keywords: KEYWORDS,\\n    contains: [\\n      'self',\\n      TUPLE_ELEMENT_NAME,\\n      ...COMMENTS,\\n      ...KEYWORD_MODES,\\n      ...BUILT_INS,\\n      ...OPERATORS,\\n      NUMBER,\\n      STRING,\\n      ...IDENTIFIERS,\\n      ...ATTRIBUTES,\\n      TYPE\\n    ]\\n  };\\n\\n  const GENERIC_PARAMETERS = {\\n    begin: /</,\\n    end: />/,\\n    contains: [\\n      ...COMMENTS,\\n      TYPE\\n    ]\\n  };\\n  const FUNCTION_PARAMETER_NAME = {\\n    begin: either(\\n      lookahead(concat(identifier, /\\\\s*:/)),\\n      lookahead(concat(identifier, /\\\\s+/, identifier, /\\\\s*:/))\\n    ),\\n    end: /:/,\\n    relevance: 0,\\n    contains: [\\n      {\\n        className: 'keyword',\\n        match: /\\\\b_\\\\b/\\n      },\\n      {\\n        className: 'params',\\n        match: identifier\\n      }\\n    ]\\n  };\\n  const FUNCTION_PARAMETERS = {\\n    begin: /\\\\(/,\\n    end: /\\\\)/,\\n    keywords: KEYWORDS,\\n    contains: [\\n      FUNCTION_PARAMETER_NAME,\\n      ...COMMENTS,\\n      ...KEYWORD_MODES,\\n      ...OPERATORS,\\n      NUMBER,\\n      STRING,\\n      ...ATTRIBUTES,\\n      TYPE,\\n      TUPLE\\n    ],\\n    endsParent: true,\\n    illegal: /[\\\"']/\\n  };\\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID362\\n  const FUNCTION = {\\n    match: [\\n      /func/,\\n      /\\\\s+/,\\n      either(QUOTED_IDENTIFIER.match, identifier, operator)\\n    ],\\n    className: {\\n      1: \\\"keyword\\\",\\n      3: \\\"title.function\\\"\\n    },\\n    contains: [\\n      GENERIC_PARAMETERS,\\n      FUNCTION_PARAMETERS,\\n      WHITESPACE\\n    ],\\n    illegal: [\\n      /\\\\[/,\\n      /%/\\n    ]\\n  };\\n\\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID375\\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID379\\n  const INIT_SUBSCRIPT = {\\n    match: [\\n      /\\\\b(?:subscript|init[?!]?)/,\\n      /\\\\s*(?=[<(])/,\\n    ],\\n    className: {\\n      1: \\\"keyword\\\"\\n    },\\n    contains: [\\n      GENERIC_PARAMETERS,\\n      FUNCTION_PARAMETERS,\\n      WHITESPACE\\n    ],\\n    illegal: /\\\\[|%/\\n  };\\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID380\\n  const OPERATOR_DECLARATION = {\\n    match: [\\n      /operator/,\\n      /\\\\s+/,\\n      operator\\n    ],\\n    className: {\\n      1: \\\"keyword\\\",\\n      3: \\\"title\\\"\\n    }\\n  };\\n\\n  // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID550\\n  const PRECEDENCEGROUP = {\\n    begin: [\\n      /precedencegroup/,\\n      /\\\\s+/,\\n      typeIdentifier\\n    ],\\n    className: {\\n      1: \\\"keyword\\\",\\n      3: \\\"title\\\"\\n    },\\n    contains: [ TYPE ],\\n    keywords: [\\n      ...precedencegroupKeywords,\\n      ...literals\\n    ],\\n    end: /}/\\n  };\\n\\n  // Add supported submodes to string interpolation.\\n  for (const variant of STRING.variants) {\\n    const interpolation = variant.contains.find(mode => mode.label === \\\"interpol\\\");\\n    // TODO: Interpolation can contain any expression, so there's room for improvement here.\\n    interpolation.keywords = KEYWORDS;\\n    const submodes = [\\n      ...KEYWORD_MODES,\\n      ...BUILT_INS,\\n      ...OPERATORS,\\n      NUMBER,\\n      STRING,\\n      ...IDENTIFIERS\\n    ];\\n    interpolation.contains = [\\n      ...submodes,\\n      {\\n        begin: /\\\\(/,\\n        end: /\\\\)/,\\n        contains: [\\n          'self',\\n          ...submodes\\n        ]\\n      }\\n    ];\\n  }\\n\\n  return {\\n    name: 'Swift',\\n    keywords: KEYWORDS,\\n    contains: [\\n      ...COMMENTS,\\n      FUNCTION,\\n      INIT_SUBSCRIPT,\\n      {\\n        beginKeywords: 'struct protocol class extension enum actor',\\n        end: '\\\\\\\\{',\\n        excludeEnd: true,\\n        keywords: KEYWORDS,\\n        contains: [\\n          hljs.inherit(hljs.TITLE_MODE, {\\n            className: \\\"title.class\\\",\\n            begin: /[A-Za-z$_][\\\\u00C0-\\\\u02B80-9A-Za-z$_]*/\\n          }),\\n          ...KEYWORD_MODES\\n        ]\\n      },\\n      OPERATOR_DECLARATION,\\n      PRECEDENCEGROUP,\\n      {\\n        beginKeywords: 'import',\\n        end: /$/,\\n        contains: [ ...COMMENTS ],\\n        relevance: 0\\n      },\\n      ...KEYWORD_MODES,\\n      ...BUILT_INS,\\n      ...OPERATORS,\\n      NUMBER,\\n      STRING,\\n      ...IDENTIFIERS,\\n      ...ATTRIBUTES,\\n      TYPE,\\n      TUPLE\\n    ]\\n  };\\n}\\n\\nmodule.exports = swift;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"concat\",\"args\",\"map\",\"x\",\"source\",\"joined\",\"join\",\"stripOptionsFromArgs\",\"opts\",\"length\",\"constructor\",\"Object\",\"splice\",\"either\",\"capture\",\"keywordWrapper\",\"keyword\",\"test\",\"dotKeywords\",\"optionalDotKeywords\",\"keywordTypes\",\"keywords\",\"literals\",\"precedencegroupKeywords\",\"numberSignKeywords\",\"builtIns\",\"operatorHead\",\"operatorCharacter\",\"operator\",\"identifierHead\",\"identifierCharacter\",\"identifier\",\"typeIdentifier\",\"keywordAttributes\",\"availabilityKeywords\",\"swift\",\"hljs\",\"WHITESPACE\",\"match\",\"relevance\",\"BLOCK_COMMENT\",\"COMMENT\",\"contains\",\"COMMENTS\",\"C_LINE_COMMENT_MODE\",\"DOT_KEYWORD\",\"className\",\"KEYWORD_GUARD\",\"PLAIN_KEYWORDS\",\"filter\",\"kw\",\"REGEX_KEYWORDS\",\"KEYWORD\",\"variants\",\"KEYWORDS\",\"$pattern\",\"literal\",\"KEYWORD_MODES\",\"BUILT_IN_GUARD\",\"BUILT_IN\",\"BUILT_INS\",\"OPERATOR_GUARD\",\"OPERATORS\",\"OPERATOR\",\"NUMBER\",\"ESCAPED_CHARACTER\",\"rawDelimiter\",\"INTERPOLATION\",\"label\",\"begin\",\"end\",\"MULTILINE_STRING\",\"SINGLE_LINE_STRING\",\"STRING\",\"QUOTED_IDENTIFIER\",\"IDENTIFIERS\",\"IMPLICIT_PARAMETER\",\"PROPERTY_WRAPPER_PROJECTION\",\"AVAILABLE_ATTRIBUTE\",\"starts\",\"KEYWORD_ATTRIBUTE\",\"USER_DEFINED_ATTRIBUTE\",\"ATTRIBUTES\",\"TYPE\",\"re\",\"GENERIC_ARGUMENTS\",\"push\",\"TUPLE_ELEMENT_NAME\",\"TUPLE\",\"GENERIC_PARAMETERS\",\"FUNCTION_PARAMETER_NAME\",\"FUNCTION_PARAMETERS\",\"endsParent\",\"illegal\",\"FUNCTION\",\"INIT_SUBSCRIPT\",\"OPERATOR_DECLARATION\",\"PRECEDENCEGROUP\",\"interpolation\",\"variant\",\"find\",\"mode\",\"submodes\",\"name\",\"beginKeywords\",\"excludeEnd\",\"inherit\",\"TITLE_MODE\"]\n}\n"]