["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/xregexp/lib/addons/matchrecursive.js"],"~:js","shadow$provide[283]=function(f,d,h,l){f=d(13);d(67)(l,\"__esModule\",{value:!0});l[\"default\"]=void 0;var k=f(d(251)),n=f(d(183)),q=f(d(243));l[\"default\"]=function(r){function v(w,t,B,z){return{name:w,value:t,start:B,end:z}}r.matchRecursive=function(w,t,B,z,I){z=z||\"\";I=I||{};var M=(0,q[\"default\"])(z).call(z,\"g\"),P=(0,q[\"default\"])(z).call(z,\"y\"),E=z.replace(/y/g,\"\"),Q=I.escapeChar;I=I.valueNames;var N=[],Z=0,D=0,X=0,da=0;t=r(t,E);B=r(B,E);if(Q){var ha,Y;if(1<Q.length)throw Error(\"Cannot use more than one escape character\");\nQ=r.escape(Q);var ea=new RegExp((0,n[\"default\"])(ha=(0,n[\"default\"])(Y=\"(?:\".concat(Q,\"[\\\\S\\\\s]|(?:(?!\")).call(Y,r.union([t,B],\"\",{conjunction:\"or\"}).source,\")[^\")).call(ha,Q,\"])+)+\"),z.replace(/[^imu]+/g,\"\"))}for(;;){Q&&(X+=(r.exec(w,ea,X,\"sticky\")||[\"\"])[0].length);z=r.exec(w,t,X);E=r.exec(w,B,X);z&&E&&(z.index<=E.index?E=null:z=null);if(z||E)D=(z||E).index,X=D+(z||E)[0].length;else if(!Z)break;if(P&&!Z&&D>da)break;if(z){if(!Z){var aa=D;var oa=X}++Z}else if(E&&Z){if(!--Z&&(I?(I[0]&&aa>da&&N.push(v(I[0],\n(0,k[\"default\"])(w).call(w,da,aa),da,aa)),I[1]&&N.push(v(I[1],(0,k[\"default\"])(w).call(w,aa,oa),aa,oa)),I[2]&&N.push(v(I[2],(0,k[\"default\"])(w).call(w,oa,D),oa,D)),I[3]&&N.push(v(I[3],(0,k[\"default\"])(w).call(w,D,X),D,X))):N.push((0,k[\"default\"])(w).call(w,oa,D)),da=X,!M))break}else throw Error(\"Unbalanced delimiter found in string\");D===X&&++X}M&&!P&&I&&I[0]&&w.length>da&&N.push(v(I[0],(0,k[\"default\"])(w).call(w,da),da,w.length));return N}};h.exports=l.default}","~:source","shadow$provide[283] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\n/*!\n * XRegExp.matchRecursive 4.4.1\n * <xregexp.com>\n * Steven Levithan (c) 2009-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  /**\n   * Returns a match detail object composed of the provided values.\n   *\n   * @private\n   */\n  function row(name, value, start, end) {\n    return {\n      name: name,\n      value: value,\n      start: start,\n      end: end\n    };\n  }\n  /**\n   * Returns an array of match strings between outermost left and right delimiters, or an array of\n   * objects with detailed match parts and position data. An error is thrown if delimiters are\n   * unbalanced within the data.\n   *\n   * @memberOf XRegExp\n   * @param {String} str String to search.\n   * @param {String} left Left delimiter as an XRegExp pattern.\n   * @param {String} right Right delimiter as an XRegExp pattern.\n   * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\n   * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n   * @returns {!Array} Array of matches, or an empty array.\n   * @example\n   *\n   * // Basic usage\n   * let str = '(t((e))s)t()(ing)';\n   * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n   * // -> ['t((e))s', '', 'ing']\n   *\n   * // Extended information mode with valueNames\n   * str = 'Here is <div> <div>an</div></div> example';\n   * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n   *   valueNames: ['between', 'left', 'match', 'right']\n   * });\n   * // -> [\n   * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n   * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n   * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n   * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n   * // {name: 'between', value: ' example',       start: 33, end: 41}\n   * // ]\n   *\n   * // Omitting unneeded parts with null valueNames, and using escapeChar\n   * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n   * XRegExp.matchRecursive(str, '{', '}', 'g', {\n   *   valueNames: ['literal', null, 'value', null],\n   *   escapeChar: '\\\\'\n   * });\n   * // -> [\n   * // {name: 'literal', value: '...',  start: 0, end: 3},\n   * // {name: 'value',   value: '1',    start: 4, end: 5},\n   * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n   * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n   * // ]\n   *\n   * // Sticky mode via flag y\n   * str = '<1><<<2>>><3>4<5>';\n   * XRegExp.matchRecursive(str, '<', '>', 'gy');\n   * // -> ['1', '<<2>>', '3']\n   */\n\n\n  XRegExp.matchRecursive = function (str, left, right, flags, options) {\n    flags = flags || '';\n    options = options || {};\n    var global = (0, _includes[\"default\"])(flags).call(flags, 'g');\n    var sticky = (0, _includes[\"default\"])(flags).call(flags, 'y'); // Flag `y` is controlled internally\n\n    var basicFlags = flags.replace(/y/g, '');\n    var _options = options,\n        escapeChar = _options.escapeChar;\n    var vN = options.valueNames;\n    var output = [];\n    var openTokens = 0;\n    var delimStart = 0;\n    var delimEnd = 0;\n    var lastOuterEnd = 0;\n    var outerStart;\n    var innerStart;\n    var leftMatch;\n    var rightMatch;\n    var esc;\n    left = XRegExp(left, basicFlags);\n    right = XRegExp(right, basicFlags);\n\n    if (escapeChar) {\n      var _context, _context2;\n\n      if (escapeChar.length > 1) {\n        throw new Error('Cannot use more than one escape character');\n      }\n\n      escapeChar = XRegExp.escape(escapeChar); // Example of concatenated `esc` regex:\n      // `escapeChar`: '%'\n      // `left`: '<'\n      // `right`: '>'\n      // Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\n\n      esc = new RegExp((0, _concat[\"default\"])(_context = (0, _concat[\"default\"])(_context2 = \"(?:\".concat(escapeChar, \"[\\\\S\\\\s]|(?:(?!\")).call(_context2, // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n      // transformation resulting from those flags was already applied to `left` and\n      // `right` when they were passed through the XRegExp constructor above.\n      XRegExp.union([left, right], '', {\n        conjunction: 'or'\n      }).source, \")[^\")).call(_context, escapeChar, \"])+)+\"), // Flags `gy` not needed here\n      flags.replace(/[^imu]+/g, ''));\n    }\n\n    while (true) {\n      // If using an escape character, advance to the delimiter's next starting position,\n      // skipping any escaped characters in between\n      if (escapeChar) {\n        delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n      }\n\n      leftMatch = XRegExp.exec(str, left, delimEnd);\n      rightMatch = XRegExp.exec(str, right, delimEnd); // Keep the leftmost match only\n\n      if (leftMatch && rightMatch) {\n        if (leftMatch.index <= rightMatch.index) {\n          rightMatch = null;\n        } else {\n          leftMatch = null;\n        }\n      } // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n      // LM | RM | OT | Result\n      // 1  | 0  | 1  | loop\n      // 1  | 0  | 0  | loop\n      // 0  | 1  | 1  | loop\n      // 0  | 1  | 0  | throw\n      // 0  | 0  | 1  | throw\n      // 0  | 0  | 0  | break\n      // The paths above don't include the sticky mode special case. The loop ends after the\n      // first completed match if not `global`.\n\n\n      if (leftMatch || rightMatch) {\n        delimStart = (leftMatch || rightMatch).index;\n        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n      } else if (!openTokens) {\n        break;\n      }\n\n      if (sticky && !openTokens && delimStart > lastOuterEnd) {\n        break;\n      }\n\n      if (leftMatch) {\n        if (!openTokens) {\n          outerStart = delimStart;\n          innerStart = delimEnd;\n        }\n\n        ++openTokens;\n      } else if (rightMatch && openTokens) {\n        if (! --openTokens) {\n          if (vN) {\n            if (vN[0] && outerStart > lastOuterEnd) {\n              output.push(row(vN[0], (0, _slice[\"default\"])(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n            }\n\n            if (vN[1]) {\n              output.push(row(vN[1], (0, _slice[\"default\"])(str).call(str, outerStart, innerStart), outerStart, innerStart));\n            }\n\n            if (vN[2]) {\n              output.push(row(vN[2], (0, _slice[\"default\"])(str).call(str, innerStart, delimStart), innerStart, delimStart));\n            }\n\n            if (vN[3]) {\n              output.push(row(vN[3], (0, _slice[\"default\"])(str).call(str, delimStart, delimEnd), delimStart, delimEnd));\n            }\n          } else {\n            output.push((0, _slice[\"default\"])(str).call(str, innerStart, delimStart));\n          }\n\n          lastOuterEnd = delimEnd;\n\n          if (!global) {\n            break;\n          }\n        }\n      } else {\n        throw new Error('Unbalanced delimiter found in string');\n      } // If the delimiter matched an empty string, avoid an infinite loop\n\n\n      if (delimStart === delimEnd) {\n        ++delimEnd;\n      }\n    }\n\n    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n      output.push(row(vN[0], (0, _slice[\"default\"])(str).call(str, lastOuterEnd), lastOuterEnd, str.length));\n    }\n\n    return output;\n  };\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$babel$runtime_corejs3$helpers$interopRequireDefault","~$shadow.js","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$includes","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$object$define_property","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$slice","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$concat"]],"~:properties",["^5",["conjunction","matchRecursive","name","value","start","end"]],"~:compiled-at",1668766213505,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$xregexp$lib$addons$matchrecursive.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAe,GAAf,CAAA,CAAsB,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAuBC,CAAvB,CAAgC,CAG1DC,CAAAA,CAAyBH,CAAA,CAAQ,EAAR,CAEAA,EAAAI,CAAQ,EAARA,CAE7B,CAAuBF,CAAvB,CAAgC,YAAhC,CAA8C,CAC5CG,MAAO,CAAA,CADqC,CAA9C,CAIAH,EAAA,CAAQ,SAAR,CAAA,CAAqB,IAAK,EAE1B,KAAII,EAASH,CAAA,CAAuBH,CAAA,CAAQ,GAAR,CAAvB,CAAb,CAEIO,EAAUJ,CAAA,CAAuBH,CAAA,CAAQ,GAAR,CAAvB,CAFd,CAIIQ,EAAYL,CAAA,CAAuBH,CAAA,CAAQ,GAAR,CAAvB,CAmNhBE,EAAA,CAAQ,SAAR,CAAA,CA5MeO,QAAiB,CAACC,CAAD,CAAU,CAMxCC,QAASA,EAAG,CAACC,CAAD,CAAOP,CAAP,CAAcQ,CAAd,CAAqBC,CAArB,CAA0B,CACpC,MAAO,CACLF,KAAMA,CADD,CAELP,MAAOA,CAFF,CAGLQ,MAAOA,CAHF,CAILC,IAAKA,CAJA,CAD6B,CA4DtCJ,CAAA,CAAQK,cAAR,CAAyBC,QAAS,CAACC,CAAD,CAAMC,CAAN,CAAYC,CAAZ,CAAmBC,CAAnB,CAA0BC,CAA1B,CAAmC,CACnED,CAAA,CAAQA,CAAR,EAAiB,EACjBC,EAAA,CAAUA,CAAV,EAAqB,EACrB,KAAItB,EAAS,CAAC,CAAA,CAAGS,CAAA,CAAU,SAAV,CAAJ,EAA0BY,CAA1B,CAAA,CAAiCE,IAAjC,CAAsCF,CAAtC,CAA6C,GAA7C,CAAb,CACIG,EAAS,CAAC,CAAA,CAAGf,CAAA,CAAU,SAAV,CAAJ,EAA0BY,CAA1B,CAAA,CAAiCE,IAAjC,CAAsCF,CAAtC,CAA6C,GAA7C,CADb,CAGII,EAAaJ,CAAA,CAAMK,OAAN,CAAc,IAAd,CAAoB,EAApB,CAHjB,CAKIC,EADWL,CACXK,CAAsBA,UACtBC,EAAAA,CAAKN,CAALM,CAAaC,UACjB,KAAIC,EAAS,EAAb,CACIC,EAAa,CADjB,CAEIC,EAAa,CAFjB,CAGIC,EAAW,CAHf,CAIIC,GAAe,CAMnBf,EAAA,CAAOR,CAAA,CAAQQ,CAAR,CAAcM,CAAd,CACPL,EAAA,CAAQT,CAAA,CAAQS,CAAR,CAAeK,CAAf,CAER,IAAIE,CAAJ,CAAgB,CAAA,IACVQ,EADU,CACAC,CAEd,IAAwB,CAAxB,CAAIT,CAAJ,CAAeU,MAAf,CACE,KAAUC,MAAJ,CAAU,2CAAV,CAAN;AAGFX,CAAA,CAAahB,CAAA,CAAQ4B,MAAR,CAAeZ,CAAf,CAMb,KAAAa,GAAM,IAAIC,MAAJ,CAAW,CAAC,CAAA,CAAGjC,CAAA,CAAQ,SAAR,CAAJ,EAAwB2B,EAAxB,CAAmC,CAAC,CAAA,CAAG3B,CAAA,CAAQ,SAAR,CAAJ,EAAwB4B,CAAxB,CAAoCM,KAAA,CAAMA,MAAN,CAAaf,CAAb,CAAyB,iBAAzB,CAApC,CAAA,CAAiFJ,IAAjF,CAAsFa,CAAtF,CAIpDzB,CAAA,CAAQgC,KAAR,CAAc,CAACxB,CAAD,CAAOC,CAAP,CAAd,CAA6B,EAA7B,CAAiC,CAC/BwB,YAAa,IADkB,CAAjC,CAJoD,CAMjDC,MANiD,CAMzC,KANyC,CAAnC,CAAA,CAMEtB,IANF,CAMOY,EANP,CAMiBR,CANjB,CAM6B,OAN7B,CAAX,CAONN,CAAA,CAAMK,OAAN,CAAc,UAAd,CAA0B,EAA1B,CAPM,CAbQ,CAuBhB,IAAA,CAAA,CAAA,CAAa,CAGPC,CAAJ,GACEM,CADF,EACc,CAACtB,CAAA,CAAQmC,IAAR,CAAa5B,CAAb,CAAkBsB,EAAlB,CAAuBP,CAAvB,CAAiC,QAAjC,CAAD,EAA+C,CAAC,EAAD,CAA/C,EAAqD,CAArD,CADd,CACsEI,MADtE,CAIAU,EAAA,CAAYpC,CAAA,CAAQmC,IAAR,CAAa5B,CAAb,CAAkBC,CAAlB,CAAwBc,CAAxB,CACZe,EAAA,CAAarC,CAAA,CAAQmC,IAAR,CAAa5B,CAAb,CAAkBE,CAAlB,CAAyBa,CAAzB,CAETc,EAAJ,EAAiBC,CAAjB,GACMD,CAAJ,CAAcE,KAAd,EAAuBD,CAAvB,CAAkCC,KAAlC,CACED,CADF,CACe,IADf,CAGED,CAHF,CAGc,IAJhB,CAkBA,IAAIA,CAAJ,EAAiBC,CAAjB,CACEhB,CACA,EADce,CACd,EAD2BC,CAC3B,EADuCC,KACvC,CAAAhB,CAAA,CAAWD,CAAX,CAAwB,CAACe,CAAD,EAAcC,CAAd,EAA0B,CAA1B,CAAxB,CAAqDX,MAFvD,KAGO,IAAI,CAACN,CAAL,CACL,KAGF,IAAIP,CAAJ,EAAc,CAACO,CAAf,EAA6BC,CAA7B,CAA0CE,EAA1C,CACE,KAGF,IAAIa,CAAJ,CAAe,CACb,GAAI,CAAChB,CAAL,CAAiB,CACf,IAAAmB,GAAalB,CACb,KAAAmB,GAAalB,CAFE,CAKjB,EAAEF,CANW,CAAf,IAOO,IAAIiB,CAAJ,EAAkBjB,CAAlB,CACL,IAAI,CAAE,EAAEA,CAAR,GACMH,CAAJ,EACMA,CAAA,CAAG,CAAH,CAYJ,EAZasB,EAYb,CAZ0BhB,EAY1B,EAXEJ,CAAA,CAAOsB,IAAP,CAAYxC,CAAA,CAAIgB,CAAA,CAAG,CAAH,CAAJ;AAAW,CAAC,CAAA,CAAGrB,CAAA,CAAO,SAAP,CAAJ,EAAuBW,CAAvB,CAAA,CAA4BK,IAA5B,CAAiCL,CAAjC,CAAsCgB,EAAtC,CAAoDgB,EAApD,CAAX,CAA4EhB,EAA5E,CAA0FgB,EAA1F,CAAZ,CAWF,CARItB,CAAA,CAAG,CAAH,CAQJ,EAPEE,CAAA,CAAOsB,IAAP,CAAYxC,CAAA,CAAIgB,CAAA,CAAG,CAAH,CAAJ,CAAW,CAAC,CAAA,CAAGrB,CAAA,CAAO,SAAP,CAAJ,EAAuBW,CAAvB,CAAA,CAA4BK,IAA5B,CAAiCL,CAAjC,CAAsCgC,EAAtC,CAAkDC,EAAlD,CAAX,CAA0ED,EAA1E,CAAsFC,EAAtF,CAAZ,CAOF,CAJIvB,CAAA,CAAG,CAAH,CAIJ,EAHEE,CAAA,CAAOsB,IAAP,CAAYxC,CAAA,CAAIgB,CAAA,CAAG,CAAH,CAAJ,CAAW,CAAC,CAAA,CAAGrB,CAAA,CAAO,SAAP,CAAJ,EAAuBW,CAAvB,CAAA,CAA4BK,IAA5B,CAAiCL,CAAjC,CAAsCiC,EAAtC,CAAkDnB,CAAlD,CAAX,CAA0EmB,EAA1E,CAAsFnB,CAAtF,CAAZ,CAGF,CAAIJ,CAAA,CAAG,CAAH,CAAJ,EACEE,CAAA,CAAOsB,IAAP,CAAYxC,CAAA,CAAIgB,CAAA,CAAG,CAAH,CAAJ,CAAW,CAAC,CAAA,CAAGrB,CAAA,CAAO,SAAP,CAAJ,EAAuBW,CAAvB,CAAA,CAA4BK,IAA5B,CAAiCL,CAAjC,CAAsCc,CAAtC,CAAkDC,CAAlD,CAAX,CAAwED,CAAxE,CAAoFC,CAApF,CAAZ,CAdJ,EAiBEH,CAAA,CAAOsB,IAAP,CAAY,CAAC,CAAA,CAAG7C,CAAA,CAAO,SAAP,CAAJ,EAAuBW,CAAvB,CAAA,CAA4BK,IAA5B,CAAiCL,CAAjC,CAAsCiC,EAAtC,CAAkDnB,CAAlD,CAAZ,CAKE,CAFJE,EAEI,CAFWD,CAEX,CAAA,CAACjC,CAvBP,EAwBI,KAxBJ,CADK,IA6BL,MAAUsC,MAAJ,CAAU,sCAAV,CAAN,CAIEN,CAAJ,GAAmBC,CAAnB,EACE,EAAEA,CAhFO,CAoFTjC,CAAJ,EAAc,CAACwB,CAAf,EAAyBI,CAAzB,EAA+BA,CAAA,CAAG,CAAH,CAA/B,EAAwCV,CAAxC,CAA4CmB,MAA5C,CAAqDH,EAArD,EACEJ,CAAA,CAAOsB,IAAP,CAAYxC,CAAA,CAAIgB,CAAA,CAAG,CAAH,CAAJ,CAAW,CAAC,CAAA,CAAGrB,CAAA,CAAO,SAAP,CAAJ,EAAuBW,CAAvB,CAAA,CAA4BK,IAA5B,CAAiCL,CAAjC,CAAsCgB,EAAtC,CAAX,CAAgEA,EAAhE,CAA8EhB,CAA9E,CAAkFmB,MAAlF,CAAZ,CAGF,OAAOP,EAtI4D,CAlE7B,CA6M1C5B,EAAA,CAAOC,OAAP,CAAiBA,CAAjB,CAAyBkD,OArOqC;\",\n\"sources\":[\"node_modules/xregexp/lib/addons/matchrecursive.js\"],\n\"sourcesContent\":[\"shadow$provide[283] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime-corejs3/helpers/interopRequireDefault\\\");\\n\\nvar _Object$defineProperty = require(\\\"@babel/runtime-corejs3/core-js-stable/object/define-property\\\");\\n\\n_Object$defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nexports[\\\"default\\\"] = void 0;\\n\\nvar _slice = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/slice\\\"));\\n\\nvar _concat = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/concat\\\"));\\n\\nvar _includes = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/includes\\\"));\\n\\n/*!\\n * XRegExp.matchRecursive 4.4.1\\n * <xregexp.com>\\n * Steven Levithan (c) 2009-present MIT License\\n */\\nvar _default = function _default(XRegExp) {\\n  /**\\n   * Returns a match detail object composed of the provided values.\\n   *\\n   * @private\\n   */\\n  function row(name, value, start, end) {\\n    return {\\n      name: name,\\n      value: value,\\n      start: start,\\n      end: end\\n    };\\n  }\\n  /**\\n   * Returns an array of match strings between outermost left and right delimiters, or an array of\\n   * objects with detailed match parts and position data. An error is thrown if delimiters are\\n   * unbalanced within the data.\\n   *\\n   * @memberOf XRegExp\\n   * @param {String} str String to search.\\n   * @param {String} left Left delimiter as an XRegExp pattern.\\n   * @param {String} right Right delimiter as an XRegExp pattern.\\n   * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\\n   * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\\n   * @returns {!Array} Array of matches, or an empty array.\\n   * @example\\n   *\\n   * // Basic usage\\n   * let str = '(t((e))s)t()(ing)';\\n   * XRegExp.matchRecursive(str, '\\\\\\\\(', '\\\\\\\\)', 'g');\\n   * // -> ['t((e))s', '', 'ing']\\n   *\\n   * // Extended information mode with valueNames\\n   * str = 'Here is <div> <div>an</div></div> example';\\n   * XRegExp.matchRecursive(str, '<div\\\\\\\\s*>', '</div>', 'gi', {\\n   *   valueNames: ['between', 'left', 'match', 'right']\\n   * });\\n   * // -> [\\n   * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\\n   * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\\n   * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\\n   * // {name: 'right',   value: '</div>',         start: 27, end: 33},\\n   * // {name: 'between', value: ' example',       start: 33, end: 41}\\n   * // ]\\n   *\\n   * // Omitting unneeded parts with null valueNames, and using escapeChar\\n   * str = '...{1}.\\\\\\\\{{function(x,y){return {y:x}}}';\\n   * XRegExp.matchRecursive(str, '{', '}', 'g', {\\n   *   valueNames: ['literal', null, 'value', null],\\n   *   escapeChar: '\\\\\\\\'\\n   * });\\n   * // -> [\\n   * // {name: 'literal', value: '...',  start: 0, end: 3},\\n   * // {name: 'value',   value: '1',    start: 4, end: 5},\\n   * // {name: 'literal', value: '.\\\\\\\\{', start: 6, end: 9},\\n   * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\\n   * // ]\\n   *\\n   * // Sticky mode via flag y\\n   * str = '<1><<<2>>><3>4<5>';\\n   * XRegExp.matchRecursive(str, '<', '>', 'gy');\\n   * // -> ['1', '<<2>>', '3']\\n   */\\n\\n\\n  XRegExp.matchRecursive = function (str, left, right, flags, options) {\\n    flags = flags || '';\\n    options = options || {};\\n    var global = (0, _includes[\\\"default\\\"])(flags).call(flags, 'g');\\n    var sticky = (0, _includes[\\\"default\\\"])(flags).call(flags, 'y'); // Flag `y` is controlled internally\\n\\n    var basicFlags = flags.replace(/y/g, '');\\n    var _options = options,\\n        escapeChar = _options.escapeChar;\\n    var vN = options.valueNames;\\n    var output = [];\\n    var openTokens = 0;\\n    var delimStart = 0;\\n    var delimEnd = 0;\\n    var lastOuterEnd = 0;\\n    var outerStart;\\n    var innerStart;\\n    var leftMatch;\\n    var rightMatch;\\n    var esc;\\n    left = XRegExp(left, basicFlags);\\n    right = XRegExp(right, basicFlags);\\n\\n    if (escapeChar) {\\n      var _context, _context2;\\n\\n      if (escapeChar.length > 1) {\\n        throw new Error('Cannot use more than one escape character');\\n      }\\n\\n      escapeChar = XRegExp.escape(escapeChar); // Example of concatenated `esc` regex:\\n      // `escapeChar`: '%'\\n      // `left`: '<'\\n      // `right`: '>'\\n      // Regex is: /(?:%[\\\\S\\\\s]|(?:(?!<|>)[^%])+)+/\\n\\n      esc = new RegExp((0, _concat[\\\"default\\\"])(_context = (0, _concat[\\\"default\\\"])(_context2 = \\\"(?:\\\".concat(escapeChar, \\\"[\\\\\\\\S\\\\\\\\s]|(?:(?!\\\")).call(_context2, // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\\n      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\\n      // transformation resulting from those flags was already applied to `left` and\\n      // `right` when they were passed through the XRegExp constructor above.\\n      XRegExp.union([left, right], '', {\\n        conjunction: 'or'\\n      }).source, \\\")[^\\\")).call(_context, escapeChar, \\\"])+)+\\\"), // Flags `gy` not needed here\\n      flags.replace(/[^imu]+/g, ''));\\n    }\\n\\n    while (true) {\\n      // If using an escape character, advance to the delimiter's next starting position,\\n      // skipping any escaped characters in between\\n      if (escapeChar) {\\n        delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\\n      }\\n\\n      leftMatch = XRegExp.exec(str, left, delimEnd);\\n      rightMatch = XRegExp.exec(str, right, delimEnd); // Keep the leftmost match only\\n\\n      if (leftMatch && rightMatch) {\\n        if (leftMatch.index <= rightMatch.index) {\\n          rightMatch = null;\\n        } else {\\n          leftMatch = null;\\n        }\\n      } // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\\n      // LM | RM | OT | Result\\n      // 1  | 0  | 1  | loop\\n      // 1  | 0  | 0  | loop\\n      // 0  | 1  | 1  | loop\\n      // 0  | 1  | 0  | throw\\n      // 0  | 0  | 1  | throw\\n      // 0  | 0  | 0  | break\\n      // The paths above don't include the sticky mode special case. The loop ends after the\\n      // first completed match if not `global`.\\n\\n\\n      if (leftMatch || rightMatch) {\\n        delimStart = (leftMatch || rightMatch).index;\\n        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\\n      } else if (!openTokens) {\\n        break;\\n      }\\n\\n      if (sticky && !openTokens && delimStart > lastOuterEnd) {\\n        break;\\n      }\\n\\n      if (leftMatch) {\\n        if (!openTokens) {\\n          outerStart = delimStart;\\n          innerStart = delimEnd;\\n        }\\n\\n        ++openTokens;\\n      } else if (rightMatch && openTokens) {\\n        if (! --openTokens) {\\n          if (vN) {\\n            if (vN[0] && outerStart > lastOuterEnd) {\\n              output.push(row(vN[0], (0, _slice[\\\"default\\\"])(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));\\n            }\\n\\n            if (vN[1]) {\\n              output.push(row(vN[1], (0, _slice[\\\"default\\\"])(str).call(str, outerStart, innerStart), outerStart, innerStart));\\n            }\\n\\n            if (vN[2]) {\\n              output.push(row(vN[2], (0, _slice[\\\"default\\\"])(str).call(str, innerStart, delimStart), innerStart, delimStart));\\n            }\\n\\n            if (vN[3]) {\\n              output.push(row(vN[3], (0, _slice[\\\"default\\\"])(str).call(str, delimStart, delimEnd), delimStart, delimEnd));\\n            }\\n          } else {\\n            output.push((0, _slice[\\\"default\\\"])(str).call(str, innerStart, delimStart));\\n          }\\n\\n          lastOuterEnd = delimEnd;\\n\\n          if (!global) {\\n            break;\\n          }\\n        }\\n      } else {\\n        throw new Error('Unbalanced delimiter found in string');\\n      } // If the delimiter matched an empty string, avoid an infinite loop\\n\\n\\n      if (delimStart === delimEnd) {\\n        ++delimEnd;\\n      }\\n    }\\n\\n    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\\n      output.push(row(vN[0], (0, _slice[\\\"default\\\"])(str).call(str, lastOuterEnd), lastOuterEnd, str.length));\\n    }\\n\\n    return output;\\n  };\\n};\\n\\nexports[\\\"default\\\"] = _default;\\nmodule.exports = exports.default;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"_Object$defineProperty\",\"value\",\"_slice\",\"_concat\",\"_includes\",\"_default\",\"XRegExp\",\"row\",\"name\",\"start\",\"end\",\"matchRecursive\",\"XRegExp.matchRecursive\",\"str\",\"left\",\"right\",\"flags\",\"options\",\"call\",\"sticky\",\"basicFlags\",\"replace\",\"escapeChar\",\"vN\",\"valueNames\",\"output\",\"openTokens\",\"delimStart\",\"delimEnd\",\"lastOuterEnd\",\"_context\",\"_context2\",\"length\",\"Error\",\"escape\",\"esc\",\"RegExp\",\"concat\",\"union\",\"conjunction\",\"source\",\"exec\",\"leftMatch\",\"rightMatch\",\"index\",\"outerStart\",\"innerStart\",\"push\",\"default\"]\n}\n"]