["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/xregexp/lib/addons/unicode-base.js"],"~:js","shadow$provide[284]=function(f,d,h,l){function k(E,Q){var N;if(\"undefined\"===typeof t[\"default\"]||null==(0,w[\"default\"])(E)){if((0,v[\"default\"])(E)||(N=n(E))||Q&&E&&\"number\"===typeof E.length){N&&(E=N);var Z=0;Q=function(){};return{s:Q,n:function(){return Z>=E.length?{done:!0}:{done:!1,value:E[Z++]}},e:function(ha){throw ha;},f:Q}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var D=!0,X=\n!1,da;return{s:function(){N=(0,r[\"default\"])(E)},n:function(){var ha=N.next();D=ha.done;return ha},e:function(ha){X=!0;da=ha},f:function(){try{if(!D&&null!=N[\"return\"])N[\"return\"]()}finally{if(X)throw da;}}}}function n(E,Q){var N;if(E){if(\"string\"===typeof E)return q(E,Q);var Z=(0,z[\"default\"])(N=Object.prototype.toString.call(E)).call(N,8,-1);\"Object\"===Z&&E.constructor&&(Z=E.constructor.name);if(\"Map\"===Z||\"Set\"===Z)return(0,B[\"default\"])(E);if(\"Arguments\"===Z||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Z))return q(E,\nQ)}}function q(E,Q){if(null==Q||Q>E.length)Q=E.length;for(var N=0,Z=Array(Q);N<Q;N++)Z[N]=E[N];return Z}f=d(13);d(67)(l,\"__esModule\",{value:!0});l[\"default\"]=void 0;var r=f(d(113)),v=f(d(118)),w=f(d(124)),t=f(d(169)),B=f(d(178)),z=f(d(251)),I=f(d(243)),M=f(d(183)),P=f(d(233));l[\"default\"]=function(E){function Q(Y){return Y.replace(/[- _]+/g,\"\").toLowerCase()}function N(Y){var ea=/^\\\\[xu](.+)/.exec(Y);return ea?X(ea[1]):Y.charCodeAt(\"\\\\\"===Y[0]?1:0)}function Z(Y){var ea=\"\",aa=-1;(0,P[\"default\"])(E).call(E,\nY,/(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/,function(oa){var ra=N(oa[1]);ra>aa+1&&(ea+=\"\\\\u\".concat(ha(da(aa+1))),ra>aa+2&&(ea+=\"-\\\\u\".concat(ha(da(ra-1)))));aa=N(oa[2]||oa[1])});65535>aa&&(ea+=\"\\\\u\".concat(ha(da(aa+1))),65534>aa&&(ea+=\"-\\\\uFFFF\"));return ea}var D={},X=E._dec,da=E._hex,ha=E._pad4;E.addToken(/\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/,function(Y,ea,aa){var oa=\"P\"===Y[1]||!!Y[2],ra=(0,I[\"default\"])(aa).call(aa,\"A\");aa=Q(Y[4]||Y[3]);var Ea=D[aa];if(\"P\"===Y[1]&&Y[2])throw new SyntaxError(\"Invalid double negation \"+\nY[0]);if(!D.hasOwnProperty(aa))throw new SyntaxError(\"Unknown Unicode token \"+Y[0]);if(Ea.inverseOf){aa=Q(Ea.inverseOf);if(!D.hasOwnProperty(aa)){var Da;throw new ReferenceError((0,M[\"default\"])(Da=\"\".concat(\"Unicode token missing data \"+Y[0],\" -\\x3e \")).call(Da,Ea.inverseOf));}Ea=D[aa];oa=!oa}if(!Ea.bmp&&!ra)throw new SyntaxError(\"Astral mode required for Unicode token \"+Y[0]);if(ra){if(\"class\"===ea)throw new SyntaxError(\"Astral mode does not support Unicode tokens within character classes\");Y=oa?\n\"a!\":\"a\\x3d\";if(!(ea=D[aa][Y])){ea=D[aa];var Aa;aa=D[aa];Da=\"\";aa.bmp&&!aa.isBmpLast&&(Da=(0,M[\"default\"])(Aa=\"[\".concat(aa.bmp,\"]\")).call(Aa,aa.astral?\"|\":\"\"));aa.astral&&(Da+=aa.astral);if(aa.isBmpLast&&aa.bmp){var ua;Da+=(0,M[\"default\"])(ua=\"\".concat(aa.astral?\"|\":\"\",\"[\")).call(ua,aa.bmp,\"]\")}Aa=oa?\"(?:(?!\".concat(Da,\")(?:[\\ud800-\\udbff][\\udc00-\\udfff]|[\\x00-ï¿¿]))\"):\"(?:\".concat(Da,\")\");ea=ea[Y]=Aa}return ea}return\"class\"===ea?oa?D[aa][\"b!\"]||(D[aa][\"b!\"]=Z(D[aa].bmp)):Ea.bmp:\"\".concat((oa?\"[^\":\n\"[\")+Ea.bmp,\"]\")},{scope:\"all\",optionalFlags:\"A\",leadChar:\"\\\\\"});E.addUnicodeData=function(Y){Y=k(Y);var ea;try{for(Y.s();!(ea=Y.n()).done;){var aa=ea.value;if(!aa.name)throw Error(\"Unicode token requires name\");if(!(aa.inverseOf||aa.bmp||aa.astral))throw Error(\"Unicode token has no character data \"+aa.name);D[Q(aa.name)]=aa;aa.alias&&(D[Q(aa.alias)]=aa)}}catch(oa){Y.e(oa)}finally{Y.f()}E.cache.flush(\"patterns\")};E._getUnicodeProperty=function(Y){Y=Q(Y);return D[Y]}};h.exports=l.default}","~:source","shadow$provide[284] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\n\nvar _getIteratorMethod2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js/get-iterator-method\"));\n\nvar _symbol = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/symbol\"));\n\nvar _from = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/from\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof _symbol[\"default\"] === \"undefined\" || (0, _getIteratorMethod2[\"default\"])(o) == null) { if ((0, _isArray[\"default\"])(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = (0, _getIterator2[\"default\"])(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { var _context4; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = (0, _slice[\"default\"])(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return (0, _from[\"default\"])(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*!\n * XRegExp Unicode Base 4.4.1\n * <xregexp.com>\n * Steven Levithan (c) 2008-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  /**\n   * Adds base support for Unicode matching:\n   * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n   *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n   *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n   *\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\n   * available to provide data for Unicode categories, scripts, blocks, and properties.\n   *\n   * @requires XRegExp\n   */\n  // ==--------------------------==\n  // Private stuff\n  // ==--------------------------==\n  // Storage for Unicode data\n  var unicode = {}; // Reuse utils\n\n  var dec = XRegExp._dec;\n  var hex = XRegExp._hex;\n  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n\n  function normalize(name) {\n    return name.replace(/[- _]+/g, '').toLowerCase();\n  } // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n\n\n  function charCode(chr) {\n    var esc = /^\\\\[xu](.+)/.exec(chr);\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\\\' ? 1 : 0);\n  } // Inverts a list of ordered BMP characters and ranges\n\n\n  function invertBmp(range) {\n    var output = '';\n    var lastEnd = -1;\n    (0, _forEach[\"default\"])(XRegExp).call(XRegExp, range, /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/, function (m) {\n      var start = charCode(m[1]);\n\n      if (start > lastEnd + 1) {\n        output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n        if (start > lastEnd + 2) {\n          output += \"-\\\\u\".concat(pad4(hex(start - 1)));\n        }\n      }\n\n      lastEnd = charCode(m[2] || m[1]);\n    });\n\n    if (lastEnd < 0xFFFF) {\n      output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n      if (lastEnd < 0xFFFE) {\n        output += '-\\\\uFFFF';\n      }\n    }\n\n    return output;\n  } // Generates an inverted BMP range on first use\n\n\n  function cacheInvertedBmp(slug) {\n    var prop = 'b!';\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\n  } // Combines and optionally negates BMP and astral data\n\n\n  function buildAstral(slug, isNegated) {\n    var item = unicode[slug];\n    var combined = '';\n\n    if (item.bmp && !item.isBmpLast) {\n      var _context;\n\n      combined = (0, _concat[\"default\"])(_context = \"[\".concat(item.bmp, \"]\")).call(_context, item.astral ? '|' : '');\n    }\n\n    if (item.astral) {\n      combined += item.astral;\n    }\n\n    if (item.isBmpLast && item.bmp) {\n      var _context2;\n\n      combined += (0, _concat[\"default\"])(_context2 = \"\".concat(item.astral ? '|' : '', \"[\")).call(_context2, item.bmp, \"]\");\n    } // Astral Unicode tokens always match a code point, never a code unit\n\n\n    return isNegated ? \"(?:(?!\".concat(combined, \")(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))\") : \"(?:\".concat(combined, \")\");\n  } // Builds a complete astral pattern on first use\n\n\n  function cacheAstral(slug, isNegated) {\n    var prop = isNegated ? 'a!' : 'a=';\n    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));\n  } // ==--------------------------==\n  // Core functionality\n  // ==--------------------------==\n\n  /*\n   * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n   */\n\n\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n  /\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {\n    var ERR_DOUBLE_NEG = 'Invalid double negation ';\n    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n    var ERR_UNKNOWN_REF = 'Unicode token missing data ';\n    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes'; // Negated via \\P{..} or \\p{^..}\n\n    var isNegated = match[1] === 'P' || !!match[2]; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n\n    var isAstralMode = (0, _includes[\"default\"])(flags).call(flags, 'A'); // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\n\n    var slug = normalize(match[4] || match[3]); // Token data object\n\n    var item = unicode[slug];\n\n    if (match[1] === 'P' && match[2]) {\n      throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\n    }\n\n    if (!unicode.hasOwnProperty(slug)) {\n      throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\n    } // Switch to the negated form of the referenced Unicode token\n\n\n    if (item.inverseOf) {\n      slug = normalize(item.inverseOf);\n\n      if (!unicode.hasOwnProperty(slug)) {\n        var _context3;\n\n        throw new ReferenceError((0, _concat[\"default\"])(_context3 = \"\".concat(ERR_UNKNOWN_REF + match[0], \" -> \")).call(_context3, item.inverseOf));\n      }\n\n      item = unicode[slug];\n      isNegated = !isNegated;\n    }\n\n    if (!(item.bmp || isAstralMode)) {\n      throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\n    }\n\n    if (isAstralMode) {\n      if (scope === 'class') {\n        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n      }\n\n      return cacheAstral(slug, isNegated);\n    }\n\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : \"\".concat((isNegated ? '[^' : '[') + item.bmp, \"]\");\n  }, {\n    scope: 'all',\n    optionalFlags: 'A',\n    leadChar: '\\\\'\n  });\n  /**\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n   *\n   * @memberOf XRegExp\n   * @param {Array} data Objects with named character ranges. Each object may have properties\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n   *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n   *   defined as the exact inverse of another token.\n   * @example\n   *\n   * // Basic use\n   * XRegExp.addUnicodeData([{\n   *   name: 'XDigit',\n   *   alias: 'Hexadecimal',\n   *   bmp: '0-9A-Fa-f'\n   * }]);\n   * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n   */\n\n  XRegExp.addUnicodeData = function (data) {\n    var ERR_NO_NAME = 'Unicode token requires name';\n    var ERR_NO_DATA = 'Unicode token has no character data ';\n\n    var _iterator = _createForOfIteratorHelper(data),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n\n        if (!item.name) {\n          throw new Error(ERR_NO_NAME);\n        }\n\n        if (!(item.inverseOf || item.bmp || item.astral)) {\n          throw new Error(ERR_NO_DATA + item.name);\n        }\n\n        unicode[normalize(item.name)] = item;\n\n        if (item.alias) {\n          unicode[normalize(item.alias)] = item;\n        }\n      } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n      // flags might now produce different results\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    XRegExp.cache.flush('patterns');\n  };\n  /**\n   * @ignore\n   *\n   * Return a reference to the internal Unicode definition structure for the given Unicode\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n   * constructs.\n   *\n   * @memberOf XRegExp\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n   *   Properties and Property Aliases.\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n   *\n   * @note\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n   *\n   * @note\n   * This method is *not* part of the officially documented API and may change or be removed in\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n   * structures set up by XRegExp.\n   */\n\n\n  XRegExp._getUnicodeProperty = function (name) {\n    var slug = normalize(name);\n    return unicode[slug];\n  };\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$babel$runtime_corejs3$core_js$get_iterator_method","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$for_each","~$module$node_modules$$babel$runtime_corejs3$helpers$interopRequireDefault","~$shadow.js","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$includes","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$array$from","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$object$define_property","~$module$node_modules$$babel$runtime_corejs3$core_js$get_iterator","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$symbol","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$slice","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$concat","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$array$is_array"]],"~:properties",["^5",["n","leadChar","s","f","e","optionalFlags","value","scope","addUnicodeData","_getUnicodeProperty","done"]],"~:compiled-at",1668766213509,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$xregexp$lib$addons$unicode_base.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/xregexp/lib/addons/unicode-base.js\"],\n\"sourcesContent\":[\"shadow$provide[284] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime-corejs3/helpers/interopRequireDefault\\\");\\n\\nvar _Object$defineProperty = require(\\\"@babel/runtime-corejs3/core-js-stable/object/define-property\\\");\\n\\n_Object$defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nexports[\\\"default\\\"] = void 0;\\n\\nvar _getIterator2 = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js/get-iterator\\\"));\\n\\nvar _isArray = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/array/is-array\\\"));\\n\\nvar _getIteratorMethod2 = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js/get-iterator-method\\\"));\\n\\nvar _symbol = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/symbol\\\"));\\n\\nvar _from = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/array/from\\\"));\\n\\nvar _slice = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/slice\\\"));\\n\\nvar _includes = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/includes\\\"));\\n\\nvar _concat = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/concat\\\"));\\n\\nvar _forEach = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/for-each\\\"));\\n\\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof _symbol[\\\"default\\\"] === \\\"undefined\\\" || (0, _getIteratorMethod2[\\\"default\\\"])(o) == null) { if ((0, _isArray[\\\"default\\\"])(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \\\"number\\\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = (0, _getIterator2[\\\"default\\\"])(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\\\"return\\\"] != null) it[\\\"return\\\"](); } finally { if (didErr) throw err; } } }; }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { var _context4; if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = (0, _slice[\\\"default\\\"])(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return (0, _from[\\\"default\\\"])(o); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\n/*!\\n * XRegExp Unicode Base 4.4.1\\n * <xregexp.com>\\n * Steven Levithan (c) 2008-present MIT License\\n */\\nvar _default = function _default(XRegExp) {\\n  /**\\n   * Adds base support for Unicode matching:\\n   * - Adds syntax `\\\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\\\P{..}` or\\n   *   `\\\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\\n   *   braces for token names that are a single letter (e.g. `\\\\pL` or `PL`).\\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\\n   *\\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\\n   * available to provide data for Unicode categories, scripts, blocks, and properties.\\n   *\\n   * @requires XRegExp\\n   */\\n  // ==--------------------------==\\n  // Private stuff\\n  // ==--------------------------==\\n  // Storage for Unicode data\\n  var unicode = {}; // Reuse utils\\n\\n  var dec = XRegExp._dec;\\n  var hex = XRegExp._hex;\\n  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\\n\\n  function normalize(name) {\\n    return name.replace(/[- _]+/g, '').toLowerCase();\\n  } // Gets the decimal code of a literal code unit, \\\\xHH, \\\\uHHHH, or a backslash-escaped literal\\n\\n\\n  function charCode(chr) {\\n    var esc = /^\\\\\\\\[xu](.+)/.exec(chr);\\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\\\\\\\' ? 1 : 0);\\n  } // Inverts a list of ordered BMP characters and ranges\\n\\n\\n  function invertBmp(range) {\\n    var output = '';\\n    var lastEnd = -1;\\n    (0, _forEach[\\\"default\\\"])(XRegExp).call(XRegExp, range, /(\\\\\\\\x..|\\\\\\\\u....|\\\\\\\\?[\\\\s\\\\S])(?:-(\\\\\\\\x..|\\\\\\\\u....|\\\\\\\\?[\\\\s\\\\S]))?/, function (m) {\\n      var start = charCode(m[1]);\\n\\n      if (start > lastEnd + 1) {\\n        output += \\\"\\\\\\\\u\\\".concat(pad4(hex(lastEnd + 1)));\\n\\n        if (start > lastEnd + 2) {\\n          output += \\\"-\\\\\\\\u\\\".concat(pad4(hex(start - 1)));\\n        }\\n      }\\n\\n      lastEnd = charCode(m[2] || m[1]);\\n    });\\n\\n    if (lastEnd < 0xFFFF) {\\n      output += \\\"\\\\\\\\u\\\".concat(pad4(hex(lastEnd + 1)));\\n\\n      if (lastEnd < 0xFFFE) {\\n        output += '-\\\\\\\\uFFFF';\\n      }\\n    }\\n\\n    return output;\\n  } // Generates an inverted BMP range on first use\\n\\n\\n  function cacheInvertedBmp(slug) {\\n    var prop = 'b!';\\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\\n  } // Combines and optionally negates BMP and astral data\\n\\n\\n  function buildAstral(slug, isNegated) {\\n    var item = unicode[slug];\\n    var combined = '';\\n\\n    if (item.bmp && !item.isBmpLast) {\\n      var _context;\\n\\n      combined = (0, _concat[\\\"default\\\"])(_context = \\\"[\\\".concat(item.bmp, \\\"]\\\")).call(_context, item.astral ? '|' : '');\\n    }\\n\\n    if (item.astral) {\\n      combined += item.astral;\\n    }\\n\\n    if (item.isBmpLast && item.bmp) {\\n      var _context2;\\n\\n      combined += (0, _concat[\\\"default\\\"])(_context2 = \\\"\\\".concat(item.astral ? '|' : '', \\\"[\\\")).call(_context2, item.bmp, \\\"]\\\");\\n    } // Astral Unicode tokens always match a code point, never a code unit\\n\\n\\n    return isNegated ? \\\"(?:(?!\\\".concat(combined, \\\")(?:[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\0-\\\\uFFFF]))\\\") : \\\"(?:\\\".concat(combined, \\\")\\\");\\n  } // Builds a complete astral pattern on first use\\n\\n\\n  function cacheAstral(slug, isNegated) {\\n    var prop = isNegated ? 'a!' : 'a=';\\n    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));\\n  } // ==--------------------------==\\n  // Core functionality\\n  // ==--------------------------==\\n\\n  /*\\n   * Add astral mode (flag A) and Unicode token syntax: `\\\\p{..}`, `\\\\P{..}`, `\\\\p{^..}`, `\\\\pC`.\\n   */\\n\\n\\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\\\p{^}`\\n  /\\\\\\\\([pP])(?:{(\\\\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {\\n    var ERR_DOUBLE_NEG = 'Invalid double negation ';\\n    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\\n    var ERR_UNKNOWN_REF = 'Unicode token missing data ';\\n    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\\n    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes'; // Negated via \\\\P{..} or \\\\p{^..}\\n\\n    var isNegated = match[1] === 'P' || !!match[2]; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\\n\\n    var isAstralMode = (0, _includes[\\\"default\\\"])(flags).call(flags, 'A'); // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\\\p{}`\\n\\n    var slug = normalize(match[4] || match[3]); // Token data object\\n\\n    var item = unicode[slug];\\n\\n    if (match[1] === 'P' && match[2]) {\\n      throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\\n    }\\n\\n    if (!unicode.hasOwnProperty(slug)) {\\n      throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\\n    } // Switch to the negated form of the referenced Unicode token\\n\\n\\n    if (item.inverseOf) {\\n      slug = normalize(item.inverseOf);\\n\\n      if (!unicode.hasOwnProperty(slug)) {\\n        var _context3;\\n\\n        throw new ReferenceError((0, _concat[\\\"default\\\"])(_context3 = \\\"\\\".concat(ERR_UNKNOWN_REF + match[0], \\\" -> \\\")).call(_context3, item.inverseOf));\\n      }\\n\\n      item = unicode[slug];\\n      isNegated = !isNegated;\\n    }\\n\\n    if (!(item.bmp || isAstralMode)) {\\n      throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\\n    }\\n\\n    if (isAstralMode) {\\n      if (scope === 'class') {\\n        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\\n      }\\n\\n      return cacheAstral(slug, isNegated);\\n    }\\n\\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : \\\"\\\".concat((isNegated ? '[^' : '[') + item.bmp, \\\"]\\\");\\n  }, {\\n    scope: 'all',\\n    optionalFlags: 'A',\\n    leadChar: '\\\\\\\\'\\n  });\\n  /**\\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\\\p` or `\\\\P`.\\n   *\\n   * @memberOf XRegExp\\n   * @param {Array} data Objects with named character ranges. Each object may have properties\\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\\n   *   `astral` data should be a combination of literal characters and `\\\\xHH` or `\\\\uHHHH` escape\\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\\n   *   defined as the exact inverse of another token.\\n   * @example\\n   *\\n   * // Basic use\\n   * XRegExp.addUnicodeData([{\\n   *   name: 'XDigit',\\n   *   alias: 'Hexadecimal',\\n   *   bmp: '0-9A-Fa-f'\\n   * }]);\\n   * XRegExp('\\\\\\\\p{XDigit}:\\\\\\\\p{Hexadecimal}+').test('0:3D'); // -> true\\n   */\\n\\n  XRegExp.addUnicodeData = function (data) {\\n    var ERR_NO_NAME = 'Unicode token requires name';\\n    var ERR_NO_DATA = 'Unicode token has no character data ';\\n\\n    var _iterator = _createForOfIteratorHelper(data),\\n        _step;\\n\\n    try {\\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\\n        var item = _step.value;\\n\\n        if (!item.name) {\\n          throw new Error(ERR_NO_NAME);\\n        }\\n\\n        if (!(item.inverseOf || item.bmp || item.astral)) {\\n          throw new Error(ERR_NO_DATA + item.name);\\n        }\\n\\n        unicode[normalize(item.name)] = item;\\n\\n        if (item.alias) {\\n          unicode[normalize(item.alias)] = item;\\n        }\\n      } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\\n      // flags might now produce different results\\n\\n    } catch (err) {\\n      _iterator.e(err);\\n    } finally {\\n      _iterator.f();\\n    }\\n\\n    XRegExp.cache.flush('patterns');\\n  };\\n  /**\\n   * @ignore\\n   *\\n   * Return a reference to the internal Unicode definition structure for the given Unicode\\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\\\p` or `\\\\P` regex\\n   * constructs.\\n   *\\n   * @memberOf XRegExp\\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\\n   *   Properties and Property Aliases.\\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\\n   *\\n   * @note\\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\\n   *\\n   * @note\\n   * This method is *not* part of the officially documented API and may change or be removed in\\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\\n   * structures set up by XRegExp.\\n   */\\n\\n\\n  XRegExp._getUnicodeProperty = function (name) {\\n    var slug = normalize(name);\\n    return unicode[slug];\\n  };\\n};\\n\\nexports[\\\"default\\\"] = _default;\\nmodule.exports = exports.default;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_createForOfIteratorHelper\",\"o\",\"allowArrayLike\",\"it\",\"_symbol\",\"_getIteratorMethod2\",\"_isArray\",\"_unsupportedIterableToArray\",\"length\",\"i\",\"F\",\"s\",\"n\",\"done\",\"value\",\"e\",\"_e\",\"f\",\"TypeError\",\"normalCompletion\",\"didErr\",\"err\",\"_getIterator2\",\"step\",\"next\",\"_e2\",\"minLen\",\"_context4\",\"_arrayLikeToArray\",\"_slice\",\"Object\",\"prototype\",\"toString\",\"call\",\"constructor\",\"name\",\"_from\",\"test\",\"arr\",\"len\",\"arr2\",\"Array\",\"_interopRequireDefault\",\"_Object$defineProperty\",\"_includes\",\"_concat\",\"_forEach\",\"_default\",\"XRegExp\",\"normalize\",\"replace\",\"toLowerCase\",\"charCode\",\"chr\",\"esc\",\"exec\",\"dec\",\"charCodeAt\",\"invertBmp\",\"range\",\"output\",\"lastEnd\",\"m\",\"start\",\"concat\",\"pad4\",\"hex\",\"unicode\",\"_dec\",\"_hex\",\"_pad4\",\"addToken\",\"match\",\"scope\",\"flags\",\"isNegated\",\"isAstralMode\",\"slug\",\"item\",\"SyntaxError\",\"ERR_DOUBLE_NEG\",\"hasOwnProperty\",\"ERR_UNKNOWN_NAME\",\"inverseOf\",\"_context3\",\"ReferenceError\",\"ERR_UNKNOWN_REF\",\"bmp\",\"ERR_ASTRAL_ONLY\",\"ERR_ASTRAL_IN_CLASS\",\"prop\",\"combined\",\"isBmpLast\",\"_context\",\"astral\",\"_context2\",\"optionalFlags\",\"leadChar\",\"addUnicodeData\",\"XRegExp.addUnicodeData\",\"data\",\"_iterator\",\"_step\",\"Error\",\"ERR_NO_NAME\",\"ERR_NO_DATA\",\"alias\",\"cache\",\"flush\",\"_getUnicodeProperty\",\"XRegExp._getUnicodeProperty\",\"default\"]\n}\n"]