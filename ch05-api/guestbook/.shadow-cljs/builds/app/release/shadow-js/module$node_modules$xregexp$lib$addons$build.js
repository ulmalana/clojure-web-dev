["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/xregexp/lib/addons/build.js"],"~:js","shadow$provide[282]=function(f,d,h,l){f=d(13);d(67)(l,\"__esModule\",{value:!0});l[\"default\"]=void 0;var k=f(d(183)),n=f(d(243)),q=f(d(274)),r=f(d(281));l[\"default\"]=function(v){function w(E){var Q=/^(?:\\(\\?:\\))*\\^/,N=/\\$(?:\\(\\?:\\))*$/;return Q.test(E)&&N.test(E)&&N.test(E.replace(/\\\\[\\s\\S]/g,\"\"))?E.replace(Q,\"\").replace(N,\"\"):E}function t(E,Q){Q=Q?\"x\":\"\";return v.isRegExp(E)?E.xregexp&&E.xregexp.captureNames?E:v(E.source,Q):v(E,Q)}function B(E){return E instanceof RegExp?E:v.escape(E)}function z(E,\nQ,N){E[\"subpattern\".concat(N)]=Q;return E}function I(E,Q,N){return E+(Q<N.length-1?\"{{subpattern\".concat(Q,\"}}\"):\"\")}var M=/(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g,P=v.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/,M],\"g\",{conjunction:\"or\"});v.tag=function(E){return function(Q){for(var N,Z,D=arguments.length,X=Array(1<D?D-1:0),da=1;da<D;da++)X[da-1]=arguments[da];D=(0,r[\"default\"])(N=(0,q[\"default\"])(X).call(X,B)).call(N,z,{});N=(0,q[\"default\"])(Z=Q.raw).call(Z,I).join(\"\");return v.build(N,\nD,E)}};v.build=function(E,Q,N){N=N||\"\";var Z=(0,n[\"default\"])(N).call(N,\"x\"),D=/^\\(\\?([\\w$]+)\\)/.exec(E);D&&(N=v._clipDuplicates(N+D[1]));var X={},da;for(da in Q)Q.hasOwnProperty(da)&&(D=t(Q[da],Z),X[da]={pattern:w(D.source),names:D.xregexp.captureNames||[]});E=t(E,Z);var ha=0,Y,ea=0,aa=[0],oa=E.xregexp.captureNames||[];E=E.source.replace(P,function(ra,Ea,Da,Aa,ua){var Ha=Ea||Da;if(Ha){var H;if(!X.hasOwnProperty(Ha))throw new ReferenceError(\"Undefined property \".concat(ra));if(Ea){var U=oa[ea];aa[++ea]=\n++ha;ra=\"(?\\x3c\".concat(U||Ha,\"\\x3e\")}else ra=\"(?:\";Y=ha;Ea=X[Ha].pattern.replace(M,function(T,ca,la){if(ca){if(U=X[Ha].names[ha-Y],++ha,U)return\"(?\\x3c\".concat(U,\"\\x3e\")}else if(la)return K=+la-1,X[Ha].names[K]?\"\\\\k\\x3c\".concat(X[Ha].names[K],\"\\x3e\"):\"\\\\\".concat(+la+Y);return T});return(0,k[\"default\"])(H=\"\".concat(ra)).call(H,Ea,\")\")}if(Aa){if(U=oa[ea],aa[++ea]=++ha,U)return\"(?\\x3c\".concat(U,\"\\x3e\")}else if(ua){var K=+ua-1;return oa[K]?\"\\\\k\\x3c\".concat(oa[K],\"\\x3e\"):\"\\\\\".concat(aa[+ua])}return ra});\nreturn v(E,N)}};h.exports=l.default}","~:source","shadow$provide[282] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\n\nvar _reduce = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/reduce\"));\n\n/*!\n * XRegExp.build 4.4.1\n * <xregexp.com>\n * Steven Levithan (c) 2012-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  var REGEX_DATA = 'xregexp';\n  var subParts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var parts = XRegExp.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/, subParts], 'g', {\n    conjunction: 'or'\n  });\n  /**\n   * Strips a leading `^` and trailing unescaped `$`, if both are present.\n   *\n   * @private\n   * @param {String} pattern Pattern to process.\n   * @returns {String} Pattern with edge anchors removed.\n   */\n\n  function deanchor(pattern) {\n    // Allow any number of empty noncapturing groups before/after anchors, because regexes\n    // built/generated by XRegExp sometimes include them\n    var leadingAnchor = /^(?:\\(\\?:\\))*\\^/;\n    var trailingAnchor = /\\$(?:\\(\\?:\\))*$/;\n\n    if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped\n    trailingAnchor.test(pattern.replace(/\\\\[\\s\\S]/g, ''))) {\n      return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');\n    }\n\n    return pattern;\n  }\n  /**\n   * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\n   *\n   * @private\n   * @param {String|RegExp} value Value to convert.\n   * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not\n   *   already a regex generated by XRegExp\n   * @returns {RegExp} XRegExp object with XRegExp syntax applied.\n   */\n\n\n  function asXRegExp(value, addFlagX) {\n    var flags = addFlagX ? 'x' : '';\n    return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? // Don't recompile, to preserve capture names\n    value : // Recompile as XRegExp\n    XRegExp(value.source, flags) : // Compile string as XRegExp\n    XRegExp(value, flags);\n  }\n\n  function interpolate(substitution) {\n    return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);\n  }\n\n  function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {\n    subpatterns[\"subpattern\".concat(subpatternIndex)] = interpolated;\n    return subpatterns;\n  }\n\n  function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {\n    var hasSubpattern = subpatternIndex < rawLiterals.length - 1;\n    return raw + (hasSubpattern ? \"{{subpattern\".concat(subpatternIndex, \"}}\") : '');\n  }\n  /**\n   * Provides tagged template literals that create regexes with XRegExp syntax and flags. The\n   * provided pattern is handled as a raw string, so backslashes don't need to be escaped.\n   *\n   * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated\n   * patterns are treated as atomic units when quantified, interpolated strings have their special\n   * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated\n   * regexes if both are present, and any backreferences within an interpolated regex are\n   * rewritten to work within the overall pattern.\n   *\n   * @memberOf XRegExp\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.\n   * @example\n   *\n   * const h12 = /1[0-2]|0?[1-9]/;\n   * const h24 = /2[0-3]|[01][0-9]/;\n   * const hours = XRegExp.tag('x')`${h12} : | ${h24}`;\n   * const minutes = /^[0-5][0-9]$/;\n   * // Note that explicitly naming the 'minutes' group is required for named backreferences\n   * const time = XRegExp.tag('x')`^ ${hours} (?<minutes>${minutes}) $`;\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\n   */\n\n\n  XRegExp.tag = function (flags) {\n    return function (literals) {\n      var _context, _context2;\n\n      for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        substitutions[_key - 1] = arguments[_key];\n      }\n\n      var subpatterns = (0, _reduce[\"default\"])(_context = (0, _map[\"default\"])(substitutions).call(substitutions, interpolate)).call(_context, reduceToSubpatternsObject, {});\n      var pattern = (0, _map[\"default\"])(_context2 = literals.raw).call(_context2, embedSubpatternAfter).join('');\n      return XRegExp.build(pattern, subpatterns, flags);\n    };\n  };\n  /**\n   * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\n   * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\n   * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\n   *\n   * @memberOf XRegExp\n   * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n   *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n   *   character classes.\n   * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\n   *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {RegExp} Regex with interpolated subpatterns.\n   * @example\n   *\n   * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n   *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\n   *     h12: /1[0-2]|0?[1-9]/,\n   *     h24: /2[0-3]|[01][0-9]/\n   *   }, 'x'),\n   *   minutes: /^[0-5][0-9]$/\n   * });\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\n   */\n\n\n  XRegExp.build = function (pattern, subs, flags) {\n    flags = flags || ''; // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how\n    // some browsers convert `RegExp('\\n')` to a regex that contains the literal characters `\\`\n    // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.\n\n    var addFlagX = (0, _includes[\"default\"])(flags).call(flags, 'x');\n    var inlineFlags = /^\\(\\?([\\w$]+)\\)/.exec(pattern); // Add flags within a leading mode modifier to the overall pattern's flags\n\n    if (inlineFlags) {\n      flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);\n    }\n\n    var data = {};\n\n    for (var p in subs) {\n      if (subs.hasOwnProperty(p)) {\n        // Passing to XRegExp enables extended syntax and ensures independent validity,\n        // lest an unescaped `(`, `)`, `[`, or trailing `\\` breaks the `(?:)` wrapper. For\n        // subpatterns provided as native regexes, it dies on octals and adds the property\n        // used to hold extended regex instance data, for simplicity.\n        var sub = asXRegExp(subs[p], addFlagX);\n        data[p] = {\n          // Deanchoring allows embedding independently useful anchored regexes. If you\n          // really need to keep your anchors, double them (i.e., `^^...$$`).\n          pattern: deanchor(sub.source),\n          names: sub[REGEX_DATA].captureNames || []\n        };\n      }\n    } // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\n    // helps keep this simple. Named captures will be put back.\n\n\n    var patternAsRegex = asXRegExp(pattern, addFlagX); // 'Caps' is short for 'captures'\n\n    var numCaps = 0;\n    var numPriorCaps;\n    var numOuterCaps = 0;\n    var outerCapsMap = [0];\n    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];\n    var output = patternAsRegex.source.replace(parts, function ($0, $1, $2, $3, $4) {\n      var subName = $1 || $2;\n      var capName;\n      var intro;\n      var localCapIndex; // Named subpattern\n\n      if (subName) {\n        var _context3;\n\n        if (!data.hasOwnProperty(subName)) {\n          throw new ReferenceError(\"Undefined property \".concat($0));\n        } // Named subpattern was wrapped in a capturing group\n\n\n        if ($1) {\n          capName = outerCapNames[numOuterCaps];\n          outerCapsMap[++numOuterCaps] = ++numCaps; // If it's a named group, preserve the name. Otherwise, use the subpattern name\n          // as the capture name\n\n          intro = \"(?<\".concat(capName || subName, \">\");\n        } else {\n          intro = '(?:';\n        }\n\n        numPriorCaps = numCaps;\n        var rewrittenSubpattern = data[subName].pattern.replace(subParts, function (match, paren, backref) {\n          // Capturing group\n          if (paren) {\n            capName = data[subName].names[numCaps - numPriorCaps];\n            ++numCaps; // If the current capture has a name, preserve the name\n\n            if (capName) {\n              return \"(?<\".concat(capName, \">\");\n            } // Backreference\n\n          } else if (backref) {\n            localCapIndex = +backref - 1; // Rewrite the backreference\n\n            return data[subName].names[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n            \"\\\\k<\".concat(data[subName].names[localCapIndex], \">\") : \"\\\\\".concat(+backref + numPriorCaps);\n          }\n\n          return match;\n        });\n        return (0, _concat[\"default\"])(_context3 = \"\".concat(intro)).call(_context3, rewrittenSubpattern, \")\");\n      } // Capturing group\n\n\n      if ($3) {\n        capName = outerCapNames[numOuterCaps];\n        outerCapsMap[++numOuterCaps] = ++numCaps; // If the current capture has a name, preserve the name\n\n        if (capName) {\n          return \"(?<\".concat(capName, \">\");\n        } // Backreference\n\n      } else if ($4) {\n        localCapIndex = +$4 - 1; // Rewrite the backreference\n\n        return outerCapNames[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n        \"\\\\k<\".concat(outerCapNames[localCapIndex], \">\") : \"\\\\\".concat(outerCapsMap[+$4]);\n      }\n\n      return $0;\n    });\n    return XRegExp(output, flags);\n  };\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$babel$runtime_corejs3$helpers$interopRequireDefault","~$shadow.js","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$includes","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$object$define_property","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$map","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$reduce","~$module$node_modules$$babel$runtime_corejs3$core_js_stable$instance$concat"]],"~:properties",["^5",["conjunction","tag","value","build","names","pattern"]],"~:compiled-at",1668766213503,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$xregexp$lib$addons$build.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/xregexp/lib/addons/build.js\"],\n\"sourcesContent\":[\"shadow$provide[282] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime-corejs3/helpers/interopRequireDefault\\\");\\n\\nvar _Object$defineProperty = require(\\\"@babel/runtime-corejs3/core-js-stable/object/define-property\\\");\\n\\n_Object$defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nexports[\\\"default\\\"] = void 0;\\n\\nvar _concat = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/concat\\\"));\\n\\nvar _includes = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/includes\\\"));\\n\\nvar _map = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/map\\\"));\\n\\nvar _reduce = _interopRequireDefault(require(\\\"@babel/runtime-corejs3/core-js-stable/instance/reduce\\\"));\\n\\n/*!\\n * XRegExp.build 4.4.1\\n * <xregexp.com>\\n * Steven Levithan (c) 2012-present MIT License\\n */\\nvar _default = function _default(XRegExp) {\\n  var REGEX_DATA = 'xregexp';\\n  var subParts = /(\\\\()(?!\\\\?)|\\\\\\\\([1-9]\\\\d*)|\\\\\\\\[\\\\s\\\\S]|\\\\[(?:[^\\\\\\\\\\\\]]|\\\\\\\\[\\\\s\\\\S])*\\\\]/g;\\n  var parts = XRegExp.union([/\\\\({{([\\\\w$]+)}}\\\\)|{{([\\\\w$]+)}}/, subParts], 'g', {\\n    conjunction: 'or'\\n  });\\n  /**\\n   * Strips a leading `^` and trailing unescaped `$`, if both are present.\\n   *\\n   * @private\\n   * @param {String} pattern Pattern to process.\\n   * @returns {String} Pattern with edge anchors removed.\\n   */\\n\\n  function deanchor(pattern) {\\n    // Allow any number of empty noncapturing groups before/after anchors, because regexes\\n    // built/generated by XRegExp sometimes include them\\n    var leadingAnchor = /^(?:\\\\(\\\\?:\\\\))*\\\\^/;\\n    var trailingAnchor = /\\\\$(?:\\\\(\\\\?:\\\\))*$/;\\n\\n    if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped\\n    trailingAnchor.test(pattern.replace(/\\\\\\\\[\\\\s\\\\S]/g, ''))) {\\n      return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');\\n    }\\n\\n    return pattern;\\n  }\\n  /**\\n   * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\\n   *\\n   * @private\\n   * @param {String|RegExp} value Value to convert.\\n   * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not\\n   *   already a regex generated by XRegExp\\n   * @returns {RegExp} XRegExp object with XRegExp syntax applied.\\n   */\\n\\n\\n  function asXRegExp(value, addFlagX) {\\n    var flags = addFlagX ? 'x' : '';\\n    return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? // Don't recompile, to preserve capture names\\n    value : // Recompile as XRegExp\\n    XRegExp(value.source, flags) : // Compile string as XRegExp\\n    XRegExp(value, flags);\\n  }\\n\\n  function interpolate(substitution) {\\n    return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);\\n  }\\n\\n  function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {\\n    subpatterns[\\\"subpattern\\\".concat(subpatternIndex)] = interpolated;\\n    return subpatterns;\\n  }\\n\\n  function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {\\n    var hasSubpattern = subpatternIndex < rawLiterals.length - 1;\\n    return raw + (hasSubpattern ? \\\"{{subpattern\\\".concat(subpatternIndex, \\\"}}\\\") : '');\\n  }\\n  /**\\n   * Provides tagged template literals that create regexes with XRegExp syntax and flags. The\\n   * provided pattern is handled as a raw string, so backslashes don't need to be escaped.\\n   *\\n   * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated\\n   * patterns are treated as atomic units when quantified, interpolated strings have their special\\n   * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated\\n   * regexes if both are present, and any backreferences within an interpolated regex are\\n   * rewritten to work within the overall pattern.\\n   *\\n   * @memberOf XRegExp\\n   * @param {String} [flags] Any combination of XRegExp flags.\\n   * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.\\n   * @example\\n   *\\n   * const h12 = /1[0-2]|0?[1-9]/;\\n   * const h24 = /2[0-3]|[01][0-9]/;\\n   * const hours = XRegExp.tag('x')`${h12} : | ${h24}`;\\n   * const minutes = /^[0-5][0-9]$/;\\n   * // Note that explicitly naming the 'minutes' group is required for named backreferences\\n   * const time = XRegExp.tag('x')`^ ${hours} (?<minutes>${minutes}) $`;\\n   * time.test('10:59'); // -> true\\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\\n   */\\n\\n\\n  XRegExp.tag = function (flags) {\\n    return function (literals) {\\n      var _context, _context2;\\n\\n      for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n        substitutions[_key - 1] = arguments[_key];\\n      }\\n\\n      var subpatterns = (0, _reduce[\\\"default\\\"])(_context = (0, _map[\\\"default\\\"])(substitutions).call(substitutions, interpolate)).call(_context, reduceToSubpatternsObject, {});\\n      var pattern = (0, _map[\\\"default\\\"])(_context2 = literals.raw).call(_context2, embedSubpatternAfter).join('');\\n      return XRegExp.build(pattern, subpatterns, flags);\\n    };\\n  };\\n  /**\\n   * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\\n   * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\\n   * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\\n   *\\n   * @memberOf XRegExp\\n   * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\\n   *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\\n   *   character classes.\\n   * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\\n   *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\\n   * @param {String} [flags] Any combination of XRegExp flags.\\n   * @returns {RegExp} Regex with interpolated subpatterns.\\n   * @example\\n   *\\n   * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\\n   *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\\n   *     h12: /1[0-2]|0?[1-9]/,\\n   *     h24: /2[0-3]|[01][0-9]/\\n   *   }, 'x'),\\n   *   minutes: /^[0-5][0-9]$/\\n   * });\\n   * time.test('10:59'); // -> true\\n   * XRegExp.exec('10:59', time).minutes; // -> '59'\\n   */\\n\\n\\n  XRegExp.build = function (pattern, subs, flags) {\\n    flags = flags || ''; // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how\\n    // some browsers convert `RegExp('\\\\n')` to a regex that contains the literal characters `\\\\`\\n    // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.\\n\\n    var addFlagX = (0, _includes[\\\"default\\\"])(flags).call(flags, 'x');\\n    var inlineFlags = /^\\\\(\\\\?([\\\\w$]+)\\\\)/.exec(pattern); // Add flags within a leading mode modifier to the overall pattern's flags\\n\\n    if (inlineFlags) {\\n      flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);\\n    }\\n\\n    var data = {};\\n\\n    for (var p in subs) {\\n      if (subs.hasOwnProperty(p)) {\\n        // Passing to XRegExp enables extended syntax and ensures independent validity,\\n        // lest an unescaped `(`, `)`, `[`, or trailing `\\\\` breaks the `(?:)` wrapper. For\\n        // subpatterns provided as native regexes, it dies on octals and adds the property\\n        // used to hold extended regex instance data, for simplicity.\\n        var sub = asXRegExp(subs[p], addFlagX);\\n        data[p] = {\\n          // Deanchoring allows embedding independently useful anchored regexes. If you\\n          // really need to keep your anchors, double them (i.e., `^^...$$`).\\n          pattern: deanchor(sub.source),\\n          names: sub[REGEX_DATA].captureNames || []\\n        };\\n      }\\n    } // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\\n    // helps keep this simple. Named captures will be put back.\\n\\n\\n    var patternAsRegex = asXRegExp(pattern, addFlagX); // 'Caps' is short for 'captures'\\n\\n    var numCaps = 0;\\n    var numPriorCaps;\\n    var numOuterCaps = 0;\\n    var outerCapsMap = [0];\\n    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];\\n    var output = patternAsRegex.source.replace(parts, function ($0, $1, $2, $3, $4) {\\n      var subName = $1 || $2;\\n      var capName;\\n      var intro;\\n      var localCapIndex; // Named subpattern\\n\\n      if (subName) {\\n        var _context3;\\n\\n        if (!data.hasOwnProperty(subName)) {\\n          throw new ReferenceError(\\\"Undefined property \\\".concat($0));\\n        } // Named subpattern was wrapped in a capturing group\\n\\n\\n        if ($1) {\\n          capName = outerCapNames[numOuterCaps];\\n          outerCapsMap[++numOuterCaps] = ++numCaps; // If it's a named group, preserve the name. Otherwise, use the subpattern name\\n          // as the capture name\\n\\n          intro = \\\"(?<\\\".concat(capName || subName, \\\">\\\");\\n        } else {\\n          intro = '(?:';\\n        }\\n\\n        numPriorCaps = numCaps;\\n        var rewrittenSubpattern = data[subName].pattern.replace(subParts, function (match, paren, backref) {\\n          // Capturing group\\n          if (paren) {\\n            capName = data[subName].names[numCaps - numPriorCaps];\\n            ++numCaps; // If the current capture has a name, preserve the name\\n\\n            if (capName) {\\n              return \\\"(?<\\\".concat(capName, \\\">\\\");\\n            } // Backreference\\n\\n          } else if (backref) {\\n            localCapIndex = +backref - 1; // Rewrite the backreference\\n\\n            return data[subName].names[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\\n            \\\"\\\\\\\\k<\\\".concat(data[subName].names[localCapIndex], \\\">\\\") : \\\"\\\\\\\\\\\".concat(+backref + numPriorCaps);\\n          }\\n\\n          return match;\\n        });\\n        return (0, _concat[\\\"default\\\"])(_context3 = \\\"\\\".concat(intro)).call(_context3, rewrittenSubpattern, \\\")\\\");\\n      } // Capturing group\\n\\n\\n      if ($3) {\\n        capName = outerCapNames[numOuterCaps];\\n        outerCapsMap[++numOuterCaps] = ++numCaps; // If the current capture has a name, preserve the name\\n\\n        if (capName) {\\n          return \\\"(?<\\\".concat(capName, \\\">\\\");\\n        } // Backreference\\n\\n      } else if ($4) {\\n        localCapIndex = +$4 - 1; // Rewrite the backreference\\n\\n        return outerCapNames[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\\n        \\\"\\\\\\\\k<\\\".concat(outerCapNames[localCapIndex], \\\">\\\") : \\\"\\\\\\\\\\\".concat(outerCapsMap[+$4]);\\n      }\\n\\n      return $0;\\n    });\\n    return XRegExp(output, flags);\\n  };\\n};\\n\\nexports[\\\"default\\\"] = _default;\\nmodule.exports = exports.default;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"_Object$defineProperty\",\"value\",\"_concat\",\"_includes\",\"_map\",\"_reduce\",\"_default\",\"XRegExp\",\"deanchor\",\"pattern\",\"leadingAnchor\",\"trailingAnchor\",\"test\",\"replace\",\"asXRegExp\",\"addFlagX\",\"flags\",\"isRegExp\",\"REGEX_DATA\",\"captureNames\",\"source\",\"interpolate\",\"substitution\",\"RegExp\",\"escape\",\"reduceToSubpatternsObject\",\"subpatterns\",\"interpolated\",\"subpatternIndex\",\"concat\",\"embedSubpatternAfter\",\"raw\",\"rawLiterals\",\"length\",\"subParts\",\"parts\",\"union\",\"conjunction\",\"tag\",\"XRegExp.tag\",\"literals\",\"_context\",\"_context2\",\"_len\",\"arguments\",\"substitutions\",\"Array\",\"_key\",\"call\",\"join\",\"build\",\"XRegExp.build\",\"subs\",\"inlineFlags\",\"exec\",\"_clipDuplicates\",\"data\",\"p\",\"hasOwnProperty\",\"sub\",\"names\",\"patternAsRegex\",\"numCaps\",\"numPriorCaps\",\"numOuterCaps\",\"outerCapsMap\",\"outerCapNames\",\"output\",\"$0\",\"$1\",\"$2\",\"$3\",\"$4\",\"subName\",\"_context3\",\"ReferenceError\",\"capName\",\"intro\",\"rewrittenSubpattern\",\"match\",\"paren\",\"backref\",\"localCapIndex\",\"default\"]\n}\n"]