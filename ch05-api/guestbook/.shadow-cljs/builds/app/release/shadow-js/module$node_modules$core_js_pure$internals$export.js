["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/core-js-pure/internals/export.js"],"~:js","shadow$provide[63]=function(f,d,h,l){f=d(14);var k=d(17),n=d(20),q=d(22),r=d(56).f,v=d(57),w=d(32),t=d(58),B=d(62),z=d(49),I=function(M){var P=function(E,Q,N){if(this instanceof P){switch(arguments.length){case 0:return new M;case 1:return new M(E);case 2:return new M(E,Q)}return new M(E,Q,N)}return k(M,this,arguments)};P.prototype=M.prototype;return P};h.exports=function(M,P){var E=M.target,Q=M.global,N=M.stat,Z=M.proto,D=Q?f:N?f[E]:(f[E]||{}).prototype,X=Q?w:w[E]||B(w,E,{})[E],da=X.prototype,ha;\nfor(ha in P){var Y=v(Q?ha:E+(N?\".\":\"#\")+ha,M.forced);var ea=!Y&&D&&z(D,ha);var aa=X[ha];if(ea)var oa=M.dontCallGetSet?(oa=r(D,ha))&&oa.value:D[ha];Y=ea&&oa?oa:P[ha];ea&&typeof aa==typeof Y||(ea=M.bind&&ea?t(Y,f):M.wrap&&ea?I(Y):Z&&q(Y)?n(Y):Y,(M.sham||Y&&Y.sham||aa&&aa.sham)&&B(ea,\"sham\",!0),B(X,ha,ea),Z&&(aa=E+\"Prototype\",z(w,aa)||B(w,aa,{}),B(w[aa],ha,Y),M.real&&da&&!da[ha]&&B(da,ha,Y)))}}}","~:source","shadow$provide[63] = function(global,require,module,exports) {\n'use strict';\nvar global = require('../internals/global');\nvar apply = require('../internals/function-apply');\nvar uncurryThis = require('../internals/function-uncurry-this-clause');\nvar isCallable = require('../internals/is-callable');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar isForced = require('../internals/is-forced');\nvar path = require('../internals/path');\nvar bind = require('../internals/function-bind-context');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar hasOwn = require('../internals/has-own-property');\n\nvar wrapConstructor = function (NativeConstructor) {\n  var Wrapper = function (a, b, c) {\n    if (this instanceof Wrapper) {\n      switch (arguments.length) {\n        case 0: return new NativeConstructor();\n        case 1: return new NativeConstructor(a);\n        case 2: return new NativeConstructor(a, b);\n      } return new NativeConstructor(a, b, c);\n    } return apply(NativeConstructor, this, arguments);\n  };\n  Wrapper.prototype = NativeConstructor.prototype;\n  return Wrapper;\n};\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var PROTO = options.proto;\n\n  var nativeSource = GLOBAL ? global : STATIC ? global[TARGET] : (global[TARGET] || {}).prototype;\n\n  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];\n  var targetPrototype = target.prototype;\n\n  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\n\n  for (key in source) {\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contains in native\n    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);\n\n    targetProperty = target[key];\n\n    if (USE_NATIVE) if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(nativeSource, key);\n      nativeProperty = descriptor && descriptor.value;\n    } else nativeProperty = nativeSource[key];\n\n    // export native or implementation\n    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];\n\n    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;\n\n    // bind timers to global for call from export context\n    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, global);\n    // wrap global constructors for prevent changs in this version\n    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);\n    // make static versions for prototype methods\n    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);\n    // default case\n    else resultProperty = sourceProperty;\n\n    // add a flag to not completely full polyfills\n    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(resultProperty, 'sham', true);\n    }\n\n    createNonEnumerableProperty(target, key, resultProperty);\n\n    if (PROTO) {\n      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';\n      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {\n        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});\n      }\n      // export virtual prototype methods\n      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);\n      // export real prototype methods\n      if (options.real && targetPrototype && !targetPrototype[key]) {\n        createNonEnumerableProperty(targetPrototype, key, sourceProperty);\n      }\n    }\n  }\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$core_js_pure$internals$function_uncurry_this_clause","~$module$node_modules$core_js_pure$internals$is_callable","~$module$node_modules$core_js_pure$internals$is_forced","~$shadow.js","~$module$node_modules$core_js_pure$internals$function_bind_context","~$module$node_modules$core_js_pure$internals$path","~$module$node_modules$core_js_pure$internals$object_get_own_property_descriptor","~$module$node_modules$core_js_pure$internals$has_own_property","~$module$node_modules$core_js_pure$internals$create_non_enumerable_property","~$module$node_modules$core_js_pure$internals$global","~$module$node_modules$core_js_pure$internals$function_apply"]],"~:properties",["^5",["prototype"]],"~:compiled-at",1668766213338,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$core_js_pure$internals$export.js\",\n\"lineCount\":2,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/core-js-pure/internals/export.js\"],\n\"sourcesContent\":[\"shadow$provide[63] = function(global,require,module,exports) {\\n'use strict';\\nvar global = require('../internals/global');\\nvar apply = require('../internals/function-apply');\\nvar uncurryThis = require('../internals/function-uncurry-this-clause');\\nvar isCallable = require('../internals/is-callable');\\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\\nvar isForced = require('../internals/is-forced');\\nvar path = require('../internals/path');\\nvar bind = require('../internals/function-bind-context');\\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\\nvar hasOwn = require('../internals/has-own-property');\\n\\nvar wrapConstructor = function (NativeConstructor) {\\n  var Wrapper = function (a, b, c) {\\n    if (this instanceof Wrapper) {\\n      switch (arguments.length) {\\n        case 0: return new NativeConstructor();\\n        case 1: return new NativeConstructor(a);\\n        case 2: return new NativeConstructor(a, b);\\n      } return new NativeConstructor(a, b, c);\\n    } return apply(NativeConstructor, this, arguments);\\n  };\\n  Wrapper.prototype = NativeConstructor.prototype;\\n  return Wrapper;\\n};\\n\\n/*\\n  options.target         - name of the target object\\n  options.global         - target is the global object\\n  options.stat           - export as static methods of target\\n  options.proto          - export as prototype methods of target\\n  options.real           - real prototype method for the `pure` version\\n  options.forced         - export even if the native feature is available\\n  options.bind           - bind methods to the target, required for the `pure` version\\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\\n  options.sham           - add a flag to not completely full polyfills\\n  options.enumerable     - export as enumerable property\\n  options.dontCallGetSet - prevent calling a getter on target\\n  options.name           - the .name of the function if it does not match the key\\n*/\\nmodule.exports = function (options, source) {\\n  var TARGET = options.target;\\n  var GLOBAL = options.global;\\n  var STATIC = options.stat;\\n  var PROTO = options.proto;\\n\\n  var nativeSource = GLOBAL ? global : STATIC ? global[TARGET] : (global[TARGET] || {}).prototype;\\n\\n  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];\\n  var targetPrototype = target.prototype;\\n\\n  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;\\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\\n\\n  for (key in source) {\\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\\n    // contains in native\\n    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);\\n\\n    targetProperty = target[key];\\n\\n    if (USE_NATIVE) if (options.dontCallGetSet) {\\n      descriptor = getOwnPropertyDescriptor(nativeSource, key);\\n      nativeProperty = descriptor && descriptor.value;\\n    } else nativeProperty = nativeSource[key];\\n\\n    // export native or implementation\\n    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];\\n\\n    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;\\n\\n    // bind timers to global for call from export context\\n    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, global);\\n    // wrap global constructors for prevent changs in this version\\n    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);\\n    // make static versions for prototype methods\\n    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);\\n    // default case\\n    else resultProperty = sourceProperty;\\n\\n    // add a flag to not completely full polyfills\\n    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {\\n      createNonEnumerableProperty(resultProperty, 'sham', true);\\n    }\\n\\n    createNonEnumerableProperty(target, key, resultProperty);\\n\\n    if (PROTO) {\\n      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';\\n      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {\\n        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});\\n      }\\n      // export virtual prototype methods\\n      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);\\n      // export real prototype methods\\n      if (options.real && targetPrototype && !targetPrototype[key]) {\\n        createNonEnumerableProperty(targetPrototype, key, sourceProperty);\\n      }\\n    }\\n  }\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"apply\",\"uncurryThis\",\"isCallable\",\"getOwnPropertyDescriptor\",\"f\",\"isForced\",\"path\",\"bind\",\"createNonEnumerableProperty\",\"hasOwn\",\"wrapConstructor\",\"NativeConstructor\",\"Wrapper\",\"a\",\"b\",\"c\",\"arguments\",\"length\",\"prototype\",\"module.exports\",\"options\",\"source\",\"TARGET\",\"target\",\"GLOBAL\",\"STATIC\",\"stat\",\"PROTO\",\"proto\",\"nativeSource\",\"targetPrototype\",\"key\",\"FORCED\",\"forced\",\"USE_NATIVE\",\"targetProperty\",\"nativeProperty\",\"dontCallGetSet\",\"descriptor\",\"value\",\"sourceProperty\",\"resultProperty\",\"wrap\",\"sham\",\"VIRTUAL_PROTOTYPE\",\"real\"]\n}\n"]